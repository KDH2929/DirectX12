// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game_message.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_game_5fmessage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_game_5fmessage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_game_5fmessage_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_game_5fmessage_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_game_5fmessage_2eproto;
namespace game {
class AllPlayerList;
struct AllPlayerListDefaultTypeInternal;
extern AllPlayerListDefaultTypeInternal _AllPlayerList_default_instance_;
class ChatEvent;
struct ChatEventDefaultTypeInternal;
extern ChatEventDefaultTypeInternal _ChatEvent_default_instance_;
class ChatSend;
struct ChatSendDefaultTypeInternal;
extern ChatSendDefaultTypeInternal _ChatSend_default_instance_;
class FireEvent;
struct FireEventDefaultTypeInternal;
extern FireEventDefaultTypeInternal _FireEvent_default_instance_;
class FireInput;
struct FireInputDefaultTypeInternal;
extern FireInputDefaultTypeInternal _FireInput_default_instance_;
class GameMessage;
struct GameMessageDefaultTypeInternal;
extern GameMessageDefaultTypeInternal _GameMessage_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class HitEvent;
struct HitEventDefaultTypeInternal;
extern HitEventDefaultTypeInternal _HitEvent_default_instance_;
class JoinRoomRequest;
struct JoinRoomRequestDefaultTypeInternal;
extern JoinRoomRequestDefaultTypeInternal _JoinRoomRequest_default_instance_;
class JoinRoomResponse;
struct JoinRoomResponseDefaultTypeInternal;
extern JoinRoomResponseDefaultTypeInternal _JoinRoomResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class MoveEvent;
struct MoveEventDefaultTypeInternal;
extern MoveEventDefaultTypeInternal _MoveEvent_default_instance_;
class MoveInput;
struct MoveInputDefaultTypeInternal;
extern MoveInputDefaultTypeInternal _MoveInput_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerStateUpdate;
struct PlayerStateUpdateDefaultTypeInternal;
extern PlayerStateUpdateDefaultTypeInternal _PlayerStateUpdate_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class Vector3;
struct Vector3DefaultTypeInternal;
extern Vector3DefaultTypeInternal _Vector3_default_instance_;
}  // namespace game
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace game {
enum StatusCode : int {
  SUCCESS = 0,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  FORBIDDEN = 403,
  NOT_FOUND = 404,
  INTERNAL_SERVER_ERROR = 500,
  BAD_GATEWAY = 502,
  SERVICE_UNAVAILABLE = 503,
  GATEWAY_TIMEOUT = 504,
  TIMEOUT = 504,
  StatusCode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  StatusCode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool StatusCode_IsValid(int value);
extern const uint32_t StatusCode_internal_data_[];
constexpr StatusCode StatusCode_MIN = static_cast<StatusCode>(0);
constexpr StatusCode StatusCode_MAX = static_cast<StatusCode>(504);
constexpr int StatusCode_ARRAYSIZE = 504 + 1;
const ::google::protobuf::EnumDescriptor*
StatusCode_descriptor();
template <typename T>
const std::string& StatusCode_Name(T value) {
  static_assert(std::is_same<T, StatusCode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to StatusCode_Name().");
  return ::google::protobuf::internal::NameOfEnum(StatusCode_descriptor(), value);
}
inline bool StatusCode_Parse(absl::string_view name, StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusCode>(
      StatusCode_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class Vector3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.Vector3) */ {
 public:
  inline Vector3() : Vector3(nullptr) {}
  ~Vector3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Vector3(::google::protobuf::internal::ConstantInitialized);

  inline Vector3(const Vector3& from)
      : Vector3(nullptr, from) {}
  Vector3(Vector3&& from) noexcept
    : Vector3() {
    *this = ::std::move(from);
  }

  inline Vector3& operator=(const Vector3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector3& operator=(Vector3&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector3* internal_default_instance() {
    return reinterpret_cast<const Vector3*>(
               &_Vector3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector3& a, Vector3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Vector3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Vector3& from) {
    Vector3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Vector3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.Vector3";
  }
  protected:
  explicit Vector3(::google::protobuf::Arena* arena);
  Vector3(::google::protobuf::Arena* arena, const Vector3& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 2;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 3;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:game.Vector3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float x_;
    float y_;
    float z_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class Result final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Result(::google::protobuf::internal::ConstantInitialized);

  inline Result(const Result& from)
      : Result(nullptr, from) {}
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Result* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Result& from) {
    Result::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Result* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.Result";
  }
  protected:
  explicit Result(::google::protobuf::Arena* arena);
  Result(::google::protobuf::Arena* arena, const Result& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kStatusCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .game.StatusCode status_code = 1;
  void clear_status_code() ;
  ::game::StatusCode status_code() const;
  void set_status_code(::game::StatusCode value);

  private:
  ::game::StatusCode _internal_status_code() const;
  void _internal_set_status_code(::game::StatusCode value);

  public:
  // @@protoc_insertion_point(class_scope:game.Result)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      27, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    int status_code_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class LoginRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoginRequest(::google::protobuf::internal::ConstantInitialized);

  inline LoginRequest(const LoginRequest& from)
      : LoginRequest(nullptr, from) {}
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.LoginRequest";
  }
  protected:
  explicit LoginRequest(::google::protobuf::Arena* arena);
  LoginRequest(::google::protobuf::Arena* arena, const LoginRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kPasswordFieldNumber = 2,
  };
  // string username = 1;
  void clear_username() ;
  const std::string& username() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* value);

  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(
      const std::string& value);
  std::string* _internal_mutable_username();

  public:
  // string password = 2;
  void clear_password() ;
  const std::string& password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* value);

  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(
      const std::string& value);
  std::string* _internal_mutable_password();

  public:
  // @@protoc_insertion_point(class_scope:game.LoginRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class JoinRoomRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.JoinRoomRequest) */ {
 public:
  inline JoinRoomRequest() : JoinRoomRequest(nullptr) {}
  ~JoinRoomRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JoinRoomRequest(::google::protobuf::internal::ConstantInitialized);

  inline JoinRoomRequest(const JoinRoomRequest& from)
      : JoinRoomRequest(nullptr, from) {}
  JoinRoomRequest(JoinRoomRequest&& from) noexcept
    : JoinRoomRequest() {
    *this = ::std::move(from);
  }

  inline JoinRoomRequest& operator=(const JoinRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomRequest& operator=(JoinRoomRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomRequest* internal_default_instance() {
    return reinterpret_cast<const JoinRoomRequest*>(
               &_JoinRoomRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(JoinRoomRequest& a, JoinRoomRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinRoomRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JoinRoomRequest& from) {
    JoinRoomRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JoinRoomRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.JoinRoomRequest";
  }
  protected:
  explicit JoinRoomRequest(::google::protobuf::Arena* arena);
  JoinRoomRequest(::google::protobuf::Arena* arena, const JoinRoomRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // uint32 room_id = 1;
  void clear_room_id() ;
  ::uint32_t room_id() const;
  void set_room_id(::uint32_t value);

  private:
  ::uint32_t _internal_room_id() const;
  void _internal_set_room_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.JoinRoomRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t room_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class HitEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.HitEvent) */ {
 public:
  inline HitEvent() : HitEvent(nullptr) {}
  ~HitEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HitEvent(::google::protobuf::internal::ConstantInitialized);

  inline HitEvent(const HitEvent& from)
      : HitEvent(nullptr, from) {}
  HitEvent(HitEvent&& from) noexcept
    : HitEvent() {
    *this = ::std::move(from);
  }

  inline HitEvent& operator=(const HitEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HitEvent& operator=(HitEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HitEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const HitEvent* internal_default_instance() {
    return reinterpret_cast<const HitEvent*>(
               &_HitEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HitEvent& a, HitEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(HitEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HitEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HitEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HitEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HitEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HitEvent& from) {
    HitEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HitEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.HitEvent";
  }
  protected:
  explicit HitEvent(::google::protobuf::Arena* arena);
  HitEvent(::google::protobuf::Arena* arena, const HitEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttackerIdFieldNumber = 1,
    kTargetIdFieldNumber = 2,
    kBulletIdFieldNumber = 3,
    kDamageFieldNumber = 4,
    kServerTimeMsFieldNumber = 6,
    kTargetHpFieldNumber = 5,
  };
  // uint32 attacker_id = 1;
  void clear_attacker_id() ;
  ::uint32_t attacker_id() const;
  void set_attacker_id(::uint32_t value);

  private:
  ::uint32_t _internal_attacker_id() const;
  void _internal_set_attacker_id(::uint32_t value);

  public:
  // uint32 target_id = 2;
  void clear_target_id() ;
  ::uint32_t target_id() const;
  void set_target_id(::uint32_t value);

  private:
  ::uint32_t _internal_target_id() const;
  void _internal_set_target_id(::uint32_t value);

  public:
  // uint32 bullet_id = 3;
  void clear_bullet_id() ;
  ::uint32_t bullet_id() const;
  void set_bullet_id(::uint32_t value);

  private:
  ::uint32_t _internal_bullet_id() const;
  void _internal_set_bullet_id(::uint32_t value);

  public:
  // uint32 damage = 4;
  void clear_damage() ;
  ::uint32_t damage() const;
  void set_damage(::uint32_t value);

  private:
  ::uint32_t _internal_damage() const;
  void _internal_set_damage(::uint32_t value);

  public:
  // uint64 server_time_ms = 6;
  void clear_server_time_ms() ;
  ::uint64_t server_time_ms() const;
  void set_server_time_ms(::uint64_t value);

  private:
  ::uint64_t _internal_server_time_ms() const;
  void _internal_set_server_time_ms(::uint64_t value);

  public:
  // uint32 target_hp = 5;
  void clear_target_hp() ;
  ::uint32_t target_hp() const;
  void set_target_hp(::uint32_t value);

  private:
  ::uint32_t _internal_target_hp() const;
  void _internal_set_target_hp(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.HitEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t attacker_id_;
    ::uint32_t target_id_;
    ::uint32_t bullet_id_;
    ::uint32_t damage_;
    ::uint64_t server_time_ms_;
    ::uint32_t target_hp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class Header final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Header(::google::protobuf::internal::ConstantInitialized);

  inline Header(const Header& from)
      : Header(nullptr, from) {}
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Header* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.Header";
  }
  protected:
  explicit Header(::google::protobuf::Arena* arena);
  Header(::google::protobuf::Arena* arena, const Header& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 2,
    kServerTimeMsFieldNumber = 3,
    kPlayerIdFieldNumber = 1,
  };
  // uint64 sequence = 2;
  void clear_sequence() ;
  ::uint64_t sequence() const;
  void set_sequence(::uint64_t value);

  private:
  ::uint64_t _internal_sequence() const;
  void _internal_set_sequence(::uint64_t value);

  public:
  // uint64 server_time_ms = 3;
  void clear_server_time_ms() ;
  ::uint64_t server_time_ms() const;
  void set_server_time_ms(::uint64_t value);

  private:
  ::uint64_t _internal_server_time_ms() const;
  void _internal_set_server_time_ms(::uint64_t value);

  public:
  // uint32 player_id = 1;
  void clear_player_id() ;
  ::uint32_t player_id() const;
  void set_player_id(::uint32_t value);

  private:
  ::uint32_t _internal_player_id() const;
  void _internal_set_player_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.Header)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t sequence_;
    ::uint64_t server_time_ms_;
    ::uint32_t player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class ChatSend final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.ChatSend) */ {
 public:
  inline ChatSend() : ChatSend(nullptr) {}
  ~ChatSend() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatSend(::google::protobuf::internal::ConstantInitialized);

  inline ChatSend(const ChatSend& from)
      : ChatSend(nullptr, from) {}
  ChatSend(ChatSend&& from) noexcept
    : ChatSend() {
    *this = ::std::move(from);
  }

  inline ChatSend& operator=(const ChatSend& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatSend& operator=(ChatSend&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatSend& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatSend* internal_default_instance() {
    return reinterpret_cast<const ChatSend*>(
               &_ChatSend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ChatSend& a, ChatSend& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatSend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatSend* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatSend* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatSend>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatSend& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChatSend& from) {
    ChatSend::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChatSend* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.ChatSend";
  }
  protected:
  explicit ChatSend(::google::protobuf::Arena* arena);
  ChatSend(::google::protobuf::Arena* arena, const ChatSend& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // @@protoc_insertion_point(class_scope:game.ChatSend)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      29, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr message_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class ChatEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.ChatEvent) */ {
 public:
  inline ChatEvent() : ChatEvent(nullptr) {}
  ~ChatEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChatEvent(::google::protobuf::internal::ConstantInitialized);

  inline ChatEvent(const ChatEvent& from)
      : ChatEvent(nullptr, from) {}
  ChatEvent(ChatEvent&& from) noexcept
    : ChatEvent() {
    *this = ::std::move(from);
  }

  inline ChatEvent& operator=(const ChatEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChatEvent& operator=(ChatEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChatEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChatEvent* internal_default_instance() {
    return reinterpret_cast<const ChatEvent*>(
               &_ChatEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ChatEvent& a, ChatEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChatEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChatEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChatEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChatEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChatEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChatEvent& from) {
    ChatEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChatEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.ChatEvent";
  }
  protected:
  explicit ChatEvent(::google::protobuf::Arena* arena);
  ChatEvent(::google::protobuf::Arena* arena, const ChatEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 2,
    kMessageFieldNumber = 3,
    kServerTimeMsFieldNumber = 4,
    kPlayerIdFieldNumber = 1,
  };
  // string nickname = 2;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // uint64 server_time_ms = 4;
  void clear_server_time_ms() ;
  ::uint64_t server_time_ms() const;
  void set_server_time_ms(::uint64_t value);

  private:
  ::uint64_t _internal_server_time_ms() const;
  void _internal_set_server_time_ms(::uint64_t value);

  public:
  // uint32 player_id = 1;
  void clear_player_id() ;
  ::uint32_t player_id() const;
  void set_player_id(::uint32_t value);

  private:
  ::uint32_t _internal_player_id() const;
  void _internal_set_player_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.ChatEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      38, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    ::uint64_t server_time_ms_;
    ::uint32_t player_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class PlayerInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::google::protobuf::internal::ConstantInitialized);

  inline PlayerInfo(const PlayerInfo& from)
      : PlayerInfo(nullptr, from) {}
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerInfo& from) {
    PlayerInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::google::protobuf::Arena* arena);
  PlayerInfo(::google::protobuf::Arena* arena, const PlayerInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 2,
    kPositionFieldNumber = 3,
    kPlayerIdFieldNumber = 1,
    kHpFieldNumber = 4,
  };
  // string nickname = 2;
  void clear_nickname() ;
  const std::string& nickname() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_nickname(Arg_&& arg, Args_... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* value);

  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(
      const std::string& value);
  std::string* _internal_mutable_nickname();

  public:
  // .game.Vector3 position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::game::Vector3& position() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_position();
  ::game::Vector3* mutable_position();
  void set_allocated_position(::game::Vector3* value);
  void unsafe_arena_set_allocated_position(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_position();

  private:
  const ::game::Vector3& _internal_position() const;
  ::game::Vector3* _internal_mutable_position();

  public:
  // uint32 player_id = 1;
  void clear_player_id() ;
  ::uint32_t player_id() const;
  void set_player_id(::uint32_t value);

  private:
  ::uint32_t _internal_player_id() const;
  void _internal_set_player_id(::uint32_t value);

  public:
  // uint32 hp = 4;
  void clear_hp() ;
  ::uint32_t hp() const;
  void set_hp(::uint32_t value);

  private:
  ::uint32_t _internal_hp() const;
  void _internal_set_hp(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.PlayerInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      32, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr nickname_;
    ::game::Vector3* position_;
    ::uint32_t player_id_;
    ::uint32_t hp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class MoveInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.MoveInput) */ {
 public:
  inline MoveInput() : MoveInput(nullptr) {}
  ~MoveInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveInput(::google::protobuf::internal::ConstantInitialized);

  inline MoveInput(const MoveInput& from)
      : MoveInput(nullptr, from) {}
  MoveInput(MoveInput&& from) noexcept
    : MoveInput() {
    *this = ::std::move(from);
  }

  inline MoveInput& operator=(const MoveInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveInput& operator=(MoveInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveInput* internal_default_instance() {
    return reinterpret_cast<const MoveInput*>(
               &_MoveInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MoveInput& a, MoveInput& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveInput& from) {
    MoveInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.MoveInput";
  }
  protected:
  explicit MoveInput(::google::protobuf::Arena* arena);
  MoveInput(::google::protobuf::Arena* arena, const MoveInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectionFieldNumber = 2,
    kPositionFieldNumber = 3,
    kTickFieldNumber = 1,
  };
  // .game.Vector3 direction = 2;
  bool has_direction() const;
  void clear_direction() ;
  const ::game::Vector3& direction() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_direction();
  ::game::Vector3* mutable_direction();
  void set_allocated_direction(::game::Vector3* value);
  void unsafe_arena_set_allocated_direction(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_direction();

  private:
  const ::game::Vector3& _internal_direction() const;
  ::game::Vector3* _internal_mutable_direction();

  public:
  // .game.Vector3 position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::game::Vector3& position() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_position();
  ::game::Vector3* mutable_position();
  void set_allocated_position(::game::Vector3* value);
  void unsafe_arena_set_allocated_position(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_position();

  private:
  const ::game::Vector3& _internal_position() const;
  ::game::Vector3* _internal_mutable_position();

  public:
  // uint64 tick = 1;
  void clear_tick() ;
  ::uint64_t tick() const;
  void set_tick(::uint64_t value);

  private:
  ::uint64_t _internal_tick() const;
  void _internal_set_tick(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.MoveInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::game::Vector3* direction_;
    ::game::Vector3* position_;
    ::uint64_t tick_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class MoveEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.MoveEvent) */ {
 public:
  inline MoveEvent() : MoveEvent(nullptr) {}
  ~MoveEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveEvent(::google::protobuf::internal::ConstantInitialized);

  inline MoveEvent(const MoveEvent& from)
      : MoveEvent(nullptr, from) {}
  MoveEvent(MoveEvent&& from) noexcept
    : MoveEvent() {
    *this = ::std::move(from);
  }

  inline MoveEvent& operator=(const MoveEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveEvent& operator=(MoveEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveEvent* internal_default_instance() {
    return reinterpret_cast<const MoveEvent*>(
               &_MoveEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MoveEvent& a, MoveEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveEvent& from) {
    MoveEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.MoveEvent";
  }
  protected:
  explicit MoveEvent(::google::protobuf::Arena* arena);
  MoveEvent(::google::protobuf::Arena* arena, const MoveEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kVelocityFieldNumber = 3,
    kServerTimeMsFieldNumber = 6,
    kPlayerIdFieldNumber = 1,
  };
  // .game.Vector3 position = 2;
  bool has_position() const;
  void clear_position() ;
  const ::game::Vector3& position() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_position();
  ::game::Vector3* mutable_position();
  void set_allocated_position(::game::Vector3* value);
  void unsafe_arena_set_allocated_position(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_position();

  private:
  const ::game::Vector3& _internal_position() const;
  ::game::Vector3* _internal_mutable_position();

  public:
  // .game.Vector3 velocity = 3;
  bool has_velocity() const;
  void clear_velocity() ;
  const ::game::Vector3& velocity() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_velocity();
  ::game::Vector3* mutable_velocity();
  void set_allocated_velocity(::game::Vector3* value);
  void unsafe_arena_set_allocated_velocity(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_velocity();

  private:
  const ::game::Vector3& _internal_velocity() const;
  ::game::Vector3* _internal_mutable_velocity();

  public:
  // uint64 server_time_ms = 6;
  void clear_server_time_ms() ;
  ::uint64_t server_time_ms() const;
  void set_server_time_ms(::uint64_t value);

  private:
  ::uint64_t _internal_server_time_ms() const;
  void _internal_set_server_time_ms(::uint64_t value);

  public:
  // uint32 player_id = 1;
  void clear_player_id() ;
  ::uint32_t player_id() const;
  void set_player_id(::uint32_t value);

  private:
  ::uint32_t _internal_player_id() const;
  void _internal_set_player_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.MoveEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::game::Vector3* position_;
    ::game::Vector3* velocity_;
    ::uint64_t server_time_ms_;
    ::uint32_t player_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class LoginResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LoginResponse(::google::protobuf::internal::ConstantInitialized);

  inline LoginResponse(const LoginResponse& from)
      : LoginResponse(nullptr, from) {}
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.LoginResponse";
  }
  protected:
  explicit LoginResponse(::google::protobuf::Arena* arena);
  LoginResponse(::google::protobuf::Arena* arena, const LoginResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionTokenFieldNumber = 3,
    kResultFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // string session_token = 3;
  void clear_session_token() ;
  const std::string& session_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_token(Arg_&& arg, Args_... args);
  std::string* mutable_session_token();
  PROTOBUF_NODISCARD std::string* release_session_token();
  void set_allocated_session_token(std::string* value);

  private:
  const std::string& _internal_session_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_token(
      const std::string& value);
  std::string* _internal_mutable_session_token();

  public:
  // .game.Result result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::game::Result& result() const;
  PROTOBUF_NODISCARD ::game::Result* release_result();
  ::game::Result* mutable_result();
  void set_allocated_result(::game::Result* value);
  void unsafe_arena_set_allocated_result(::game::Result* value);
  ::game::Result* unsafe_arena_release_result();

  private:
  const ::game::Result& _internal_result() const;
  ::game::Result* _internal_mutable_result();

  public:
  // uint32 player_id = 2;
  void clear_player_id() ;
  ::uint32_t player_id() const;
  void set_player_id(::uint32_t value);

  private:
  ::uint32_t _internal_player_id() const;
  void _internal_set_player_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.LoginResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      40, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr session_token_;
    ::game::Result* result_;
    ::uint32_t player_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class FireInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.FireInput) */ {
 public:
  inline FireInput() : FireInput(nullptr) {}
  ~FireInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FireInput(::google::protobuf::internal::ConstantInitialized);

  inline FireInput(const FireInput& from)
      : FireInput(nullptr, from) {}
  FireInput(FireInput&& from) noexcept
    : FireInput() {
    *this = ::std::move(from);
  }

  inline FireInput& operator=(const FireInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline FireInput& operator=(FireInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FireInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const FireInput* internal_default_instance() {
    return reinterpret_cast<const FireInput*>(
               &_FireInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FireInput& a, FireInput& b) {
    a.Swap(&b);
  }
  inline void Swap(FireInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FireInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FireInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FireInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FireInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FireInput& from) {
    FireInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FireInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.FireInput";
  }
  protected:
  explicit FireInput(::google::protobuf::Arena* arena);
  FireInput(::google::protobuf::Arena* arena, const FireInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kTickFieldNumber = 1,
    kWeaponIdFieldNumber = 2,
    kSeedFieldNumber = 5,
  };
  // .game.Vector3 origin = 3;
  bool has_origin() const;
  void clear_origin() ;
  const ::game::Vector3& origin() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_origin();
  ::game::Vector3* mutable_origin();
  void set_allocated_origin(::game::Vector3* value);
  void unsafe_arena_set_allocated_origin(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_origin();

  private:
  const ::game::Vector3& _internal_origin() const;
  ::game::Vector3* _internal_mutable_origin();

  public:
  // .game.Vector3 direction = 4;
  bool has_direction() const;
  void clear_direction() ;
  const ::game::Vector3& direction() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_direction();
  ::game::Vector3* mutable_direction();
  void set_allocated_direction(::game::Vector3* value);
  void unsafe_arena_set_allocated_direction(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_direction();

  private:
  const ::game::Vector3& _internal_direction() const;
  ::game::Vector3* _internal_mutable_direction();

  public:
  // uint64 tick = 1;
  void clear_tick() ;
  ::uint64_t tick() const;
  void set_tick(::uint64_t value);

  private:
  ::uint64_t _internal_tick() const;
  void _internal_set_tick(::uint64_t value);

  public:
  // uint32 weapon_id = 2;
  void clear_weapon_id() ;
  ::uint32_t weapon_id() const;
  void set_weapon_id(::uint32_t value);

  private:
  ::uint32_t _internal_weapon_id() const;
  void _internal_set_weapon_id(::uint32_t value);

  public:
  // uint32 seed = 5;
  void clear_seed() ;
  ::uint32_t seed() const;
  void set_seed(::uint32_t value);

  private:
  ::uint32_t _internal_seed() const;
  void _internal_set_seed(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.FireInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::game::Vector3* origin_;
    ::game::Vector3* direction_;
    ::uint64_t tick_;
    ::uint32_t weapon_id_;
    ::uint32_t seed_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class FireEvent final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.FireEvent) */ {
 public:
  inline FireEvent() : FireEvent(nullptr) {}
  ~FireEvent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FireEvent(::google::protobuf::internal::ConstantInitialized);

  inline FireEvent(const FireEvent& from)
      : FireEvent(nullptr, from) {}
  FireEvent(FireEvent&& from) noexcept
    : FireEvent() {
    *this = ::std::move(from);
  }

  inline FireEvent& operator=(const FireEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FireEvent& operator=(FireEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FireEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FireEvent* internal_default_instance() {
    return reinterpret_cast<const FireEvent*>(
               &_FireEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FireEvent& a, FireEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(FireEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FireEvent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FireEvent* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FireEvent>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FireEvent& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FireEvent& from) {
    FireEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FireEvent* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.FireEvent";
  }
  protected:
  explicit FireEvent(::google::protobuf::Arena* arena);
  FireEvent(::google::protobuf::Arena* arena, const FireEvent& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginFieldNumber = 3,
    kDirectionFieldNumber = 4,
    kPlayerIdFieldNumber = 1,
    kBulletIdFieldNumber = 2,
    kServerTimeMsFieldNumber = 5,
  };
  // .game.Vector3 origin = 3;
  bool has_origin() const;
  void clear_origin() ;
  const ::game::Vector3& origin() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_origin();
  ::game::Vector3* mutable_origin();
  void set_allocated_origin(::game::Vector3* value);
  void unsafe_arena_set_allocated_origin(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_origin();

  private:
  const ::game::Vector3& _internal_origin() const;
  ::game::Vector3* _internal_mutable_origin();

  public:
  // .game.Vector3 direction = 4;
  bool has_direction() const;
  void clear_direction() ;
  const ::game::Vector3& direction() const;
  PROTOBUF_NODISCARD ::game::Vector3* release_direction();
  ::game::Vector3* mutable_direction();
  void set_allocated_direction(::game::Vector3* value);
  void unsafe_arena_set_allocated_direction(::game::Vector3* value);
  ::game::Vector3* unsafe_arena_release_direction();

  private:
  const ::game::Vector3& _internal_direction() const;
  ::game::Vector3* _internal_mutable_direction();

  public:
  // uint32 player_id = 1;
  void clear_player_id() ;
  ::uint32_t player_id() const;
  void set_player_id(::uint32_t value);

  private:
  ::uint32_t _internal_player_id() const;
  void _internal_set_player_id(::uint32_t value);

  public:
  // uint32 bullet_id = 2;
  void clear_bullet_id() ;
  ::uint32_t bullet_id() const;
  void set_bullet_id(::uint32_t value);

  private:
  ::uint32_t _internal_bullet_id() const;
  void _internal_set_bullet_id(::uint32_t value);

  public:
  // uint64 server_time_ms = 5;
  void clear_server_time_ms() ;
  ::uint64_t server_time_ms() const;
  void set_server_time_ms(::uint64_t value);

  private:
  ::uint64_t _internal_server_time_ms() const;
  void _internal_set_server_time_ms(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.FireEvent)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::game::Vector3* origin_;
    ::game::Vector3* direction_;
    ::uint32_t player_id_;
    ::uint32_t bullet_id_;
    ::uint64_t server_time_ms_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class PlayerStateUpdate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.PlayerStateUpdate) */ {
 public:
  inline PlayerStateUpdate() : PlayerStateUpdate(nullptr) {}
  ~PlayerStateUpdate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PlayerStateUpdate(::google::protobuf::internal::ConstantInitialized);

  inline PlayerStateUpdate(const PlayerStateUpdate& from)
      : PlayerStateUpdate(nullptr, from) {}
  PlayerStateUpdate(PlayerStateUpdate&& from) noexcept
    : PlayerStateUpdate() {
    *this = ::std::move(from);
  }

  inline PlayerStateUpdate& operator=(const PlayerStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerStateUpdate& operator=(PlayerStateUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerStateUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerStateUpdate* internal_default_instance() {
    return reinterpret_cast<const PlayerStateUpdate*>(
               &_PlayerStateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PlayerStateUpdate& a, PlayerStateUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerStateUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerStateUpdate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerStateUpdate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerStateUpdate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PlayerStateUpdate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PlayerStateUpdate& from) {
    PlayerStateUpdate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(PlayerStateUpdate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.PlayerStateUpdate";
  }
  protected:
  explicit PlayerStateUpdate(::google::protobuf::Arena* arena);
  PlayerStateUpdate(::google::protobuf::Arena* arena, const PlayerStateUpdate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersUpdatedFieldNumber = 1,
    kPlayersRemovedFieldNumber = 2,
  };
  // repeated .game.PlayerInfo players_updated = 1;
  int players_updated_size() const;
  private:
  int _internal_players_updated_size() const;

  public:
  void clear_players_updated() ;
  ::game::PlayerInfo* mutable_players_updated(int index);
  ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo >*
      mutable_players_updated();
  private:
  const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>& _internal_players_updated() const;
  ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>* _internal_mutable_players_updated();
  public:
  const ::game::PlayerInfo& players_updated(int index) const;
  ::game::PlayerInfo* add_players_updated();
  const ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo >&
      players_updated() const;
  // repeated uint32 players_removed = 2;
  int players_removed_size() const;
  private:
  int _internal_players_removed_size() const;

  public:
  void clear_players_removed() ;
  ::uint32_t players_removed(int index) const;
  void set_players_removed(int index, ::uint32_t value);
  void add_players_removed(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& players_removed() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_players_removed();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_players_removed() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_players_removed();

  public:
  // @@protoc_insertion_point(class_scope:game.PlayerStateUpdate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo > players_updated_;
    ::google::protobuf::RepeatedField<::uint32_t> players_removed_;
    mutable ::google::protobuf::internal::CachedSize _players_removed_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class JoinRoomResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.JoinRoomResponse) */ {
 public:
  inline JoinRoomResponse() : JoinRoomResponse(nullptr) {}
  ~JoinRoomResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR JoinRoomResponse(::google::protobuf::internal::ConstantInitialized);

  inline JoinRoomResponse(const JoinRoomResponse& from)
      : JoinRoomResponse(nullptr, from) {}
  JoinRoomResponse(JoinRoomResponse&& from) noexcept
    : JoinRoomResponse() {
    *this = ::std::move(from);
  }

  inline JoinRoomResponse& operator=(const JoinRoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline JoinRoomResponse& operator=(JoinRoomResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JoinRoomResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const JoinRoomResponse* internal_default_instance() {
    return reinterpret_cast<const JoinRoomResponse*>(
               &_JoinRoomResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(JoinRoomResponse& a, JoinRoomResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(JoinRoomResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JoinRoomResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  JoinRoomResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<JoinRoomResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const JoinRoomResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const JoinRoomResponse& from) {
    JoinRoomResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(JoinRoomResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.JoinRoomResponse";
  }
  protected:
  explicit JoinRoomResponse(::google::protobuf::Arena* arena);
  JoinRoomResponse(::google::protobuf::Arena* arena, const JoinRoomResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerListFieldNumber = 3,
    kResultFieldNumber = 1,
    kRoomIdFieldNumber = 2,
  };
  // repeated .game.PlayerInfo player_list = 3;
  int player_list_size() const;
  private:
  int _internal_player_list_size() const;

  public:
  void clear_player_list() ;
  ::game::PlayerInfo* mutable_player_list(int index);
  ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo >*
      mutable_player_list();
  private:
  const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>& _internal_player_list() const;
  ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>* _internal_mutable_player_list();
  public:
  const ::game::PlayerInfo& player_list(int index) const;
  ::game::PlayerInfo* add_player_list();
  const ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo >&
      player_list() const;
  // .game.Result result = 1;
  bool has_result() const;
  void clear_result() ;
  const ::game::Result& result() const;
  PROTOBUF_NODISCARD ::game::Result* release_result();
  ::game::Result* mutable_result();
  void set_allocated_result(::game::Result* value);
  void unsafe_arena_set_allocated_result(::game::Result* value);
  ::game::Result* unsafe_arena_release_result();

  private:
  const ::game::Result& _internal_result() const;
  ::game::Result* _internal_mutable_result();

  public:
  // uint32 room_id = 2;
  void clear_room_id() ;
  ::uint32_t room_id() const;
  void set_room_id(::uint32_t value);

  private:
  ::uint32_t _internal_room_id() const;
  void _internal_set_room_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:game.JoinRoomResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo > player_list_;
    ::game::Result* result_;
    ::uint32_t room_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class AllPlayerList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.AllPlayerList) */ {
 public:
  inline AllPlayerList() : AllPlayerList(nullptr) {}
  ~AllPlayerList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AllPlayerList(::google::protobuf::internal::ConstantInitialized);

  inline AllPlayerList(const AllPlayerList& from)
      : AllPlayerList(nullptr, from) {}
  AllPlayerList(AllPlayerList&& from) noexcept
    : AllPlayerList() {
    *this = ::std::move(from);
  }

  inline AllPlayerList& operator=(const AllPlayerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline AllPlayerList& operator=(AllPlayerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AllPlayerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const AllPlayerList* internal_default_instance() {
    return reinterpret_cast<const AllPlayerList*>(
               &_AllPlayerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(AllPlayerList& a, AllPlayerList& b) {
    a.Swap(&b);
  }
  inline void Swap(AllPlayerList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AllPlayerList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AllPlayerList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AllPlayerList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AllPlayerList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AllPlayerList& from) {
    AllPlayerList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AllPlayerList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.AllPlayerList";
  }
  protected:
  explicit AllPlayerList(::google::protobuf::Arena* arena);
  AllPlayerList(::google::protobuf::Arena* arena, const AllPlayerList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .game.PlayerInfo players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;

  public:
  void clear_players() ;
  ::game::PlayerInfo* mutable_players(int index);
  ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo >*
      mutable_players();
  private:
  const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>& _internal_players() const;
  ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>* _internal_mutable_players();
  public:
  const ::game::PlayerInfo& players(int index) const;
  ::game::PlayerInfo* add_players();
  const ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo >&
      players() const;
  // @@protoc_insertion_point(class_scope:game.AllPlayerList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::game::PlayerInfo > players_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};// -------------------------------------------------------------------

class GameMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:game.GameMessage) */ {
 public:
  inline GameMessage() : GameMessage(nullptr) {}
  ~GameMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GameMessage(::google::protobuf::internal::ConstantInitialized);

  inline GameMessage(const GameMessage& from)
      : GameMessage(nullptr, from) {}
  GameMessage(GameMessage&& from) noexcept
    : GameMessage() {
    *this = ::std::move(from);
  }

  inline GameMessage& operator=(const GameMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMessage& operator=(GameMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameMessage& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kLoginRequest = 10,
    kLoginResponse = 11,
    kJoinRoomRequest = 12,
    kJoinRoomResponse = 13,
    kChatSend = 20,
    kChatEvent = 21,
    kMoveInput = 30,
    kMoveEvent = 31,
    kFireInput = 32,
    kFireEvent = 33,
    kHitEvent = 34,
    kAllPlayerList = 40,
    kPlayerStateUpdate = 41,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const GameMessage* internal_default_instance() {
    return reinterpret_cast<const GameMessage*>(
               &_GameMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GameMessage& a, GameMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GameMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GameMessage& from) {
    GameMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GameMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "game.GameMessage";
  }
  protected:
  explicit GameMessage(::google::protobuf::Arena* arena);
  GameMessage(::google::protobuf::Arena* arena, const GameMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kLoginRequestFieldNumber = 10,
    kLoginResponseFieldNumber = 11,
    kJoinRoomRequestFieldNumber = 12,
    kJoinRoomResponseFieldNumber = 13,
    kChatSendFieldNumber = 20,
    kChatEventFieldNumber = 21,
    kMoveInputFieldNumber = 30,
    kMoveEventFieldNumber = 31,
    kFireInputFieldNumber = 32,
    kFireEventFieldNumber = 33,
    kHitEventFieldNumber = 34,
    kAllPlayerListFieldNumber = 40,
    kPlayerStateUpdateFieldNumber = 41,
  };
  // .game.Header header = 1;
  bool has_header() const;
  void clear_header() ;
  const ::game::Header& header() const;
  PROTOBUF_NODISCARD ::game::Header* release_header();
  ::game::Header* mutable_header();
  void set_allocated_header(::game::Header* value);
  void unsafe_arena_set_allocated_header(::game::Header* value);
  ::game::Header* unsafe_arena_release_header();

  private:
  const ::game::Header& _internal_header() const;
  ::game::Header* _internal_mutable_header();

  public:
  // .game.LoginRequest login_request = 10;
  bool has_login_request() const;
  private:
  bool _internal_has_login_request() const;

  public:
  void clear_login_request() ;
  const ::game::LoginRequest& login_request() const;
  PROTOBUF_NODISCARD ::game::LoginRequest* release_login_request();
  ::game::LoginRequest* mutable_login_request();
  void set_allocated_login_request(::game::LoginRequest* value);
  void unsafe_arena_set_allocated_login_request(::game::LoginRequest* value);
  ::game::LoginRequest* unsafe_arena_release_login_request();

  private:
  const ::game::LoginRequest& _internal_login_request() const;
  ::game::LoginRequest* _internal_mutable_login_request();

  public:
  // .game.LoginResponse login_response = 11;
  bool has_login_response() const;
  private:
  bool _internal_has_login_response() const;

  public:
  void clear_login_response() ;
  const ::game::LoginResponse& login_response() const;
  PROTOBUF_NODISCARD ::game::LoginResponse* release_login_response();
  ::game::LoginResponse* mutable_login_response();
  void set_allocated_login_response(::game::LoginResponse* value);
  void unsafe_arena_set_allocated_login_response(::game::LoginResponse* value);
  ::game::LoginResponse* unsafe_arena_release_login_response();

  private:
  const ::game::LoginResponse& _internal_login_response() const;
  ::game::LoginResponse* _internal_mutable_login_response();

  public:
  // .game.JoinRoomRequest join_room_request = 12;
  bool has_join_room_request() const;
  private:
  bool _internal_has_join_room_request() const;

  public:
  void clear_join_room_request() ;
  const ::game::JoinRoomRequest& join_room_request() const;
  PROTOBUF_NODISCARD ::game::JoinRoomRequest* release_join_room_request();
  ::game::JoinRoomRequest* mutable_join_room_request();
  void set_allocated_join_room_request(::game::JoinRoomRequest* value);
  void unsafe_arena_set_allocated_join_room_request(::game::JoinRoomRequest* value);
  ::game::JoinRoomRequest* unsafe_arena_release_join_room_request();

  private:
  const ::game::JoinRoomRequest& _internal_join_room_request() const;
  ::game::JoinRoomRequest* _internal_mutable_join_room_request();

  public:
  // .game.JoinRoomResponse join_room_response = 13;
  bool has_join_room_response() const;
  private:
  bool _internal_has_join_room_response() const;

  public:
  void clear_join_room_response() ;
  const ::game::JoinRoomResponse& join_room_response() const;
  PROTOBUF_NODISCARD ::game::JoinRoomResponse* release_join_room_response();
  ::game::JoinRoomResponse* mutable_join_room_response();
  void set_allocated_join_room_response(::game::JoinRoomResponse* value);
  void unsafe_arena_set_allocated_join_room_response(::game::JoinRoomResponse* value);
  ::game::JoinRoomResponse* unsafe_arena_release_join_room_response();

  private:
  const ::game::JoinRoomResponse& _internal_join_room_response() const;
  ::game::JoinRoomResponse* _internal_mutable_join_room_response();

  public:
  // .game.ChatSend chat_send = 20;
  bool has_chat_send() const;
  private:
  bool _internal_has_chat_send() const;

  public:
  void clear_chat_send() ;
  const ::game::ChatSend& chat_send() const;
  PROTOBUF_NODISCARD ::game::ChatSend* release_chat_send();
  ::game::ChatSend* mutable_chat_send();
  void set_allocated_chat_send(::game::ChatSend* value);
  void unsafe_arena_set_allocated_chat_send(::game::ChatSend* value);
  ::game::ChatSend* unsafe_arena_release_chat_send();

  private:
  const ::game::ChatSend& _internal_chat_send() const;
  ::game::ChatSend* _internal_mutable_chat_send();

  public:
  // .game.ChatEvent chat_event = 21;
  bool has_chat_event() const;
  private:
  bool _internal_has_chat_event() const;

  public:
  void clear_chat_event() ;
  const ::game::ChatEvent& chat_event() const;
  PROTOBUF_NODISCARD ::game::ChatEvent* release_chat_event();
  ::game::ChatEvent* mutable_chat_event();
  void set_allocated_chat_event(::game::ChatEvent* value);
  void unsafe_arena_set_allocated_chat_event(::game::ChatEvent* value);
  ::game::ChatEvent* unsafe_arena_release_chat_event();

  private:
  const ::game::ChatEvent& _internal_chat_event() const;
  ::game::ChatEvent* _internal_mutable_chat_event();

  public:
  // .game.MoveInput move_input = 30;
  bool has_move_input() const;
  private:
  bool _internal_has_move_input() const;

  public:
  void clear_move_input() ;
  const ::game::MoveInput& move_input() const;
  PROTOBUF_NODISCARD ::game::MoveInput* release_move_input();
  ::game::MoveInput* mutable_move_input();
  void set_allocated_move_input(::game::MoveInput* value);
  void unsafe_arena_set_allocated_move_input(::game::MoveInput* value);
  ::game::MoveInput* unsafe_arena_release_move_input();

  private:
  const ::game::MoveInput& _internal_move_input() const;
  ::game::MoveInput* _internal_mutable_move_input();

  public:
  // .game.MoveEvent move_event = 31;
  bool has_move_event() const;
  private:
  bool _internal_has_move_event() const;

  public:
  void clear_move_event() ;
  const ::game::MoveEvent& move_event() const;
  PROTOBUF_NODISCARD ::game::MoveEvent* release_move_event();
  ::game::MoveEvent* mutable_move_event();
  void set_allocated_move_event(::game::MoveEvent* value);
  void unsafe_arena_set_allocated_move_event(::game::MoveEvent* value);
  ::game::MoveEvent* unsafe_arena_release_move_event();

  private:
  const ::game::MoveEvent& _internal_move_event() const;
  ::game::MoveEvent* _internal_mutable_move_event();

  public:
  // .game.FireInput fire_input = 32;
  bool has_fire_input() const;
  private:
  bool _internal_has_fire_input() const;

  public:
  void clear_fire_input() ;
  const ::game::FireInput& fire_input() const;
  PROTOBUF_NODISCARD ::game::FireInput* release_fire_input();
  ::game::FireInput* mutable_fire_input();
  void set_allocated_fire_input(::game::FireInput* value);
  void unsafe_arena_set_allocated_fire_input(::game::FireInput* value);
  ::game::FireInput* unsafe_arena_release_fire_input();

  private:
  const ::game::FireInput& _internal_fire_input() const;
  ::game::FireInput* _internal_mutable_fire_input();

  public:
  // .game.FireEvent fire_event = 33;
  bool has_fire_event() const;
  private:
  bool _internal_has_fire_event() const;

  public:
  void clear_fire_event() ;
  const ::game::FireEvent& fire_event() const;
  PROTOBUF_NODISCARD ::game::FireEvent* release_fire_event();
  ::game::FireEvent* mutable_fire_event();
  void set_allocated_fire_event(::game::FireEvent* value);
  void unsafe_arena_set_allocated_fire_event(::game::FireEvent* value);
  ::game::FireEvent* unsafe_arena_release_fire_event();

  private:
  const ::game::FireEvent& _internal_fire_event() const;
  ::game::FireEvent* _internal_mutable_fire_event();

  public:
  // .game.HitEvent hit_event = 34;
  bool has_hit_event() const;
  private:
  bool _internal_has_hit_event() const;

  public:
  void clear_hit_event() ;
  const ::game::HitEvent& hit_event() const;
  PROTOBUF_NODISCARD ::game::HitEvent* release_hit_event();
  ::game::HitEvent* mutable_hit_event();
  void set_allocated_hit_event(::game::HitEvent* value);
  void unsafe_arena_set_allocated_hit_event(::game::HitEvent* value);
  ::game::HitEvent* unsafe_arena_release_hit_event();

  private:
  const ::game::HitEvent& _internal_hit_event() const;
  ::game::HitEvent* _internal_mutable_hit_event();

  public:
  // .game.AllPlayerList all_player_list = 40;
  bool has_all_player_list() const;
  private:
  bool _internal_has_all_player_list() const;

  public:
  void clear_all_player_list() ;
  const ::game::AllPlayerList& all_player_list() const;
  PROTOBUF_NODISCARD ::game::AllPlayerList* release_all_player_list();
  ::game::AllPlayerList* mutable_all_player_list();
  void set_allocated_all_player_list(::game::AllPlayerList* value);
  void unsafe_arena_set_allocated_all_player_list(::game::AllPlayerList* value);
  ::game::AllPlayerList* unsafe_arena_release_all_player_list();

  private:
  const ::game::AllPlayerList& _internal_all_player_list() const;
  ::game::AllPlayerList* _internal_mutable_all_player_list();

  public:
  // .game.PlayerStateUpdate player_state_update = 41;
  bool has_player_state_update() const;
  private:
  bool _internal_has_player_state_update() const;

  public:
  void clear_player_state_update() ;
  const ::game::PlayerStateUpdate& player_state_update() const;
  PROTOBUF_NODISCARD ::game::PlayerStateUpdate* release_player_state_update();
  ::game::PlayerStateUpdate* mutable_player_state_update();
  void set_allocated_player_state_update(::game::PlayerStateUpdate* value);
  void unsafe_arena_set_allocated_player_state_update(::game::PlayerStateUpdate* value);
  ::game::PlayerStateUpdate* unsafe_arena_release_player_state_update();

  private:
  const ::game::PlayerStateUpdate& _internal_player_state_update() const;
  ::game::PlayerStateUpdate* _internal_mutable_player_state_update();

  public:
  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:game.GameMessage)
 private:
  class _Internal;
  void set_has_login_request();
  void set_has_login_response();
  void set_has_join_room_request();
  void set_has_join_room_response();
  void set_has_chat_send();
  void set_has_chat_event();
  void set_has_move_input();
  void set_has_move_event();
  void set_has_fire_input();
  void set_has_fire_event();
  void set_has_hit_event();
  void set_has_all_player_list();
  void set_has_player_state_update();

  inline bool has_payload() const;
  inline void clear_has_payload();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 14, 14,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::game::Header* header_;
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::game::LoginRequest* login_request_;
      ::game::LoginResponse* login_response_;
      ::game::JoinRoomRequest* join_room_request_;
      ::game::JoinRoomResponse* join_room_response_;
      ::game::ChatSend* chat_send_;
      ::game::ChatEvent* chat_event_;
      ::game::MoveInput* move_input_;
      ::game::MoveEvent* move_event_;
      ::game::FireInput* fire_input_;
      ::game::FireEvent* fire_event_;
      ::game::HitEvent* hit_event_;
      ::game::AllPlayerList* all_player_list_;
      ::game::PlayerStateUpdate* player_state_update_;
    } payload_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_game_5fmessage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Vector3

// float x = 1;
inline void Vector3::clear_x() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_ = 0;
}
inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:game.Vector3.x)
  return _internal_x();
}
inline void Vector3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:game.Vector3.x)
}
inline float Vector3::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Vector3::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_ = value;
}

// float y = 2;
inline void Vector3::clear_y() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_ = 0;
}
inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:game.Vector3.y)
  return _internal_y();
}
inline void Vector3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:game.Vector3.y)
}
inline float Vector3::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Vector3::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.y_ = value;
}

// float z = 3;
inline void Vector3::clear_z() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.z_ = 0;
}
inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:game.Vector3.z)
  return _internal_z();
}
inline void Vector3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:game.Vector3.z)
}
inline float Vector3::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Vector3::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Result

// .game.StatusCode status_code = 1;
inline void Result::clear_status_code() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.status_code_ = 0;
}
inline ::game::StatusCode Result::status_code() const {
  // @@protoc_insertion_point(field_get:game.Result.status_code)
  return _internal_status_code();
}
inline void Result::set_status_code(::game::StatusCode value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:game.Result.status_code)
}
inline ::game::StatusCode Result::_internal_status_code() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::game::StatusCode>(_impl_.status_code_);
}
inline void Result::_internal_set_status_code(::game::StatusCode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_code_ = value;
}

// string message = 2;
inline void Result::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Result::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.Result.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Result::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:game.Result.message)
}
inline std::string* Result::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:game.Result.message)
  return _s;
}
inline const std::string& Result::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void Result::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Result::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Result::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.Result.message)
  return _impl_.message_.Release();
}
inline void Result::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.Result.message)
}

// -------------------------------------------------------------------

// Header

// uint32 player_id = 1;
inline void Header::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = 0u;
}
inline ::uint32_t Header::player_id() const {
  // @@protoc_insertion_point(field_get:game.Header.player_id)
  return _internal_player_id();
}
inline void Header::set_player_id(::uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:game.Header.player_id)
}
inline ::uint32_t Header::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_;
}
inline void Header::_internal_set_player_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_ = value;
}

// uint64 sequence = 2;
inline void Header::clear_sequence() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sequence_ = ::uint64_t{0u};
}
inline ::uint64_t Header::sequence() const {
  // @@protoc_insertion_point(field_get:game.Header.sequence)
  return _internal_sequence();
}
inline void Header::set_sequence(::uint64_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:game.Header.sequence)
}
inline ::uint64_t Header::_internal_sequence() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sequence_;
}
inline void Header::_internal_set_sequence(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sequence_ = value;
}

// uint64 server_time_ms = 3;
inline void Header::clear_server_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_time_ms_ = ::uint64_t{0u};
}
inline ::uint64_t Header::server_time_ms() const {
  // @@protoc_insertion_point(field_get:game.Header.server_time_ms)
  return _internal_server_time_ms();
}
inline void Header::set_server_time_ms(::uint64_t value) {
  _internal_set_server_time_ms(value);
  // @@protoc_insertion_point(field_set:game.Header.server_time_ms)
}
inline ::uint64_t Header::_internal_server_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_time_ms_;
}
inline void Header::_internal_set_server_time_ms(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.server_time_ms_ = value;
}

// -------------------------------------------------------------------

// LoginRequest

// string username = 1;
inline void LoginRequest::clear_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.ClearToEmpty();
}
inline const std::string& LoginRequest::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.LoginRequest.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_username(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:game.LoginRequest.username)
}
inline std::string* LoginRequest::mutable_username() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:game.LoginRequest.username)
  return _s;
}
inline const std::string& LoginRequest::_internal_username() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.username_.Get();
}
inline void LoginRequest::_internal_set_username(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.username_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.username_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_username() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.LoginRequest.username)
  return _impl_.username_.Release();
}
inline void LoginRequest::set_allocated_username(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.username_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.username_.IsDefault()) {
          _impl_.username_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequest.username)
}

// string password = 2;
inline void LoginRequest::clear_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.ClearToEmpty();
}
inline const std::string& LoginRequest::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.LoginRequest.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginRequest::set_password(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:game.LoginRequest.password)
}
inline std::string* LoginRequest::mutable_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:game.LoginRequest.password)
  return _s;
}
inline const std::string& LoginRequest::_internal_password() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.password_.Get();
}
inline void LoginRequest::_internal_set_password(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.password_.Set(value, GetArena());
}
inline std::string* LoginRequest::_internal_mutable_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.password_.Mutable( GetArena());
}
inline std::string* LoginRequest::release_password() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.LoginRequest.password)
  return _impl_.password_.Release();
}
inline void LoginRequest::set_allocated_password(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.password_.IsDefault()) {
          _impl_.password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginRequest.password)
}

// -------------------------------------------------------------------

// LoginResponse

// .game.Result result = 1;
inline bool LoginResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void LoginResponse::clear_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::game::Result& LoginResponse::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Result* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Result&>(::game::_Result_default_instance_);
}
inline const ::game::Result& LoginResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.LoginResponse.result)
  return _internal_result();
}
inline void LoginResponse::unsafe_arena_set_allocated_result(::game::Result* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::game::Result*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.LoginResponse.result)
}
inline ::game::Result* LoginResponse::release_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Result* released = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Result* LoginResponse::unsafe_arena_release_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.LoginResponse.result)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::game::Result* LoginResponse::_internal_mutable_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Result>(GetArena());
    _impl_.result_ = reinterpret_cast<::game::Result*>(p);
  }
  return _impl_.result_;
}
inline ::game::Result* LoginResponse::mutable_result() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:game.LoginResponse.result)
  return _msg;
}
inline void LoginResponse::set_allocated_result(::game::Result* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Result*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Result*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_ = reinterpret_cast<::game::Result*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponse.result)
}

// uint32 player_id = 2;
inline void LoginResponse::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = 0u;
}
inline ::uint32_t LoginResponse::player_id() const {
  // @@protoc_insertion_point(field_get:game.LoginResponse.player_id)
  return _internal_player_id();
}
inline void LoginResponse::set_player_id(::uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:game.LoginResponse.player_id)
}
inline ::uint32_t LoginResponse::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_;
}
inline void LoginResponse::_internal_set_player_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_ = value;
}

// string session_token = 3;
inline void LoginResponse::clear_session_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_token_.ClearToEmpty();
}
inline const std::string& LoginResponse::session_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.LoginResponse.session_token)
  return _internal_session_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void LoginResponse::set_session_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:game.LoginResponse.session_token)
}
inline std::string* LoginResponse::mutable_session_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_token();
  // @@protoc_insertion_point(field_mutable:game.LoginResponse.session_token)
  return _s;
}
inline const std::string& LoginResponse::_internal_session_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.session_token_.Get();
}
inline void LoginResponse::_internal_set_session_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.session_token_.Set(value, GetArena());
}
inline std::string* LoginResponse::_internal_mutable_session_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.session_token_.Mutable( GetArena());
}
inline std::string* LoginResponse::release_session_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.LoginResponse.session_token)
  return _impl_.session_token_.Release();
}
inline void LoginResponse::set_allocated_session_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.session_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_token_.IsDefault()) {
          _impl_.session_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.LoginResponse.session_token)
}

// -------------------------------------------------------------------

// JoinRoomRequest

// uint32 room_id = 1;
inline void JoinRoomRequest::clear_room_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.room_id_ = 0u;
}
inline ::uint32_t JoinRoomRequest::room_id() const {
  // @@protoc_insertion_point(field_get:game.JoinRoomRequest.room_id)
  return _internal_room_id();
}
inline void JoinRoomRequest::set_room_id(::uint32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:game.JoinRoomRequest.room_id)
}
inline ::uint32_t JoinRoomRequest::_internal_room_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.room_id_;
}
inline void JoinRoomRequest::_internal_set_room_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.room_id_ = value;
}

// -------------------------------------------------------------------

// JoinRoomResponse

// .game.Result result = 1;
inline bool JoinRoomResponse::has_result() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_ != nullptr);
  return value;
}
inline void JoinRoomResponse::clear_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.result_ != nullptr) _impl_.result_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::game::Result& JoinRoomResponse::_internal_result() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Result* p = _impl_.result_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Result&>(::game::_Result_default_instance_);
}
inline const ::game::Result& JoinRoomResponse::result() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.JoinRoomResponse.result)
  return _internal_result();
}
inline void JoinRoomResponse::unsafe_arena_set_allocated_result(::game::Result* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_);
  }
  _impl_.result_ = reinterpret_cast<::game::Result*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.JoinRoomResponse.result)
}
inline ::game::Result* JoinRoomResponse::release_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Result* released = _impl_.result_;
  _impl_.result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Result* JoinRoomResponse::unsafe_arena_release_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.JoinRoomResponse.result)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Result* temp = _impl_.result_;
  _impl_.result_ = nullptr;
  return temp;
}
inline ::game::Result* JoinRoomResponse::_internal_mutable_result() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Result>(GetArena());
    _impl_.result_ = reinterpret_cast<::game::Result*>(p);
  }
  return _impl_.result_;
}
inline ::game::Result* JoinRoomResponse::mutable_result() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Result* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:game.JoinRoomResponse.result)
  return _msg;
}
inline void JoinRoomResponse::set_allocated_result(::game::Result* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Result*>(_impl_.result_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Result*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_ = reinterpret_cast<::game::Result*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.JoinRoomResponse.result)
}

// uint32 room_id = 2;
inline void JoinRoomResponse::clear_room_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.room_id_ = 0u;
}
inline ::uint32_t JoinRoomResponse::room_id() const {
  // @@protoc_insertion_point(field_get:game.JoinRoomResponse.room_id)
  return _internal_room_id();
}
inline void JoinRoomResponse::set_room_id(::uint32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:game.JoinRoomResponse.room_id)
}
inline ::uint32_t JoinRoomResponse::_internal_room_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.room_id_;
}
inline void JoinRoomResponse::_internal_set_room_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.room_id_ = value;
}

// repeated .game.PlayerInfo player_list = 3;
inline int JoinRoomResponse::_internal_player_list_size() const {
  return _internal_player_list().size();
}
inline int JoinRoomResponse::player_list_size() const {
  return _internal_player_list_size();
}
inline void JoinRoomResponse::clear_player_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_list_.Clear();
}
inline ::game::PlayerInfo* JoinRoomResponse::mutable_player_list(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:game.JoinRoomResponse.player_list)
  return _internal_mutable_player_list()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>* JoinRoomResponse::mutable_player_list()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:game.JoinRoomResponse.player_list)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_player_list();
}
inline const ::game::PlayerInfo& JoinRoomResponse::player_list(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.JoinRoomResponse.player_list)
  return _internal_player_list().Get(index);
}
inline ::game::PlayerInfo* JoinRoomResponse::add_player_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::game::PlayerInfo* _add = _internal_mutable_player_list()->Add();
  // @@protoc_insertion_point(field_add:game.JoinRoomResponse.player_list)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>& JoinRoomResponse::player_list() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:game.JoinRoomResponse.player_list)
  return _internal_player_list();
}
inline const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>&
JoinRoomResponse::_internal_player_list() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_list_;
}
inline ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>*
JoinRoomResponse::_internal_mutable_player_list() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.player_list_;
}

// -------------------------------------------------------------------

// ChatSend

// string message = 1;
inline void ChatSend::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatSend::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.ChatSend.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatSend::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:game.ChatSend.message)
}
inline std::string* ChatSend::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:game.ChatSend.message)
  return _s;
}
inline const std::string& ChatSend::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ChatSend::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ChatSend::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ChatSend::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.ChatSend.message)
  return _impl_.message_.Release();
}
inline void ChatSend::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.ChatSend.message)
}

// -------------------------------------------------------------------

// ChatEvent

// uint32 player_id = 1;
inline void ChatEvent::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = 0u;
}
inline ::uint32_t ChatEvent::player_id() const {
  // @@protoc_insertion_point(field_get:game.ChatEvent.player_id)
  return _internal_player_id();
}
inline void ChatEvent::set_player_id(::uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:game.ChatEvent.player_id)
}
inline ::uint32_t ChatEvent::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_;
}
inline void ChatEvent::_internal_set_player_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_ = value;
}

// string nickname = 2;
inline void ChatEvent::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& ChatEvent::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.ChatEvent.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatEvent::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:game.ChatEvent.nickname)
}
inline std::string* ChatEvent::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:game.ChatEvent.nickname)
  return _s;
}
inline const std::string& ChatEvent::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void ChatEvent::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* ChatEvent::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* ChatEvent::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.ChatEvent.nickname)
  return _impl_.nickname_.Release();
}
inline void ChatEvent::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.ChatEvent.nickname)
}

// string message = 3;
inline void ChatEvent::clear_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ChatEvent::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.ChatEvent.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChatEvent::set_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:game.ChatEvent.message)
}
inline std::string* ChatEvent::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:game.ChatEvent.message)
  return _s;
}
inline const std::string& ChatEvent::_internal_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.message_.Get();
}
inline void ChatEvent::_internal_set_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.message_.Set(value, GetArena());
}
inline std::string* ChatEvent::_internal_mutable_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* ChatEvent::release_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.ChatEvent.message)
  return _impl_.message_.Release();
}
inline void ChatEvent::set_allocated_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.ChatEvent.message)
}

// uint64 server_time_ms = 4;
inline void ChatEvent::clear_server_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_time_ms_ = ::uint64_t{0u};
}
inline ::uint64_t ChatEvent::server_time_ms() const {
  // @@protoc_insertion_point(field_get:game.ChatEvent.server_time_ms)
  return _internal_server_time_ms();
}
inline void ChatEvent::set_server_time_ms(::uint64_t value) {
  _internal_set_server_time_ms(value);
  // @@protoc_insertion_point(field_set:game.ChatEvent.server_time_ms)
}
inline ::uint64_t ChatEvent::_internal_server_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_time_ms_;
}
inline void ChatEvent::_internal_set_server_time_ms(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.server_time_ms_ = value;
}

// -------------------------------------------------------------------

// MoveInput

// uint64 tick = 1;
inline void MoveInput::clear_tick() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tick_ = ::uint64_t{0u};
}
inline ::uint64_t MoveInput::tick() const {
  // @@protoc_insertion_point(field_get:game.MoveInput.tick)
  return _internal_tick();
}
inline void MoveInput::set_tick(::uint64_t value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:game.MoveInput.tick)
}
inline ::uint64_t MoveInput::_internal_tick() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tick_;
}
inline void MoveInput::_internal_set_tick(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tick_ = value;
}

// .game.Vector3 direction = 2;
inline bool MoveInput::has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.direction_ != nullptr);
  return value;
}
inline void MoveInput::clear_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::game::Vector3& MoveInput::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& MoveInput::direction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.MoveInput.direction)
  return _internal_direction();
}
inline void MoveInput::unsafe_arena_set_allocated_direction(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.MoveInput.direction)
}
inline ::game::Vector3* MoveInput::release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* released = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* MoveInput::unsafe_arena_release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.MoveInput.direction)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::game::Vector3* MoveInput::_internal_mutable_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.direction_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.direction_;
}
inline ::game::Vector3* MoveInput::mutable_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:game.MoveInput.direction)
  return _msg;
}
inline void MoveInput::set_allocated_direction(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.direction_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.MoveInput.direction)
}

// .game.Vector3 position = 3;
inline bool MoveInput::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void MoveInput::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::game::Vector3& MoveInput::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& MoveInput::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.MoveInput.position)
  return _internal_position();
}
inline void MoveInput::unsafe_arena_set_allocated_position(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.MoveInput.position)
}
inline ::game::Vector3* MoveInput::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::game::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* MoveInput::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.MoveInput.position)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::game::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::game::Vector3* MoveInput::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::game::Vector3* MoveInput::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:game.MoveInput.position)
  return _msg;
}
inline void MoveInput::set_allocated_position(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.position_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.MoveInput.position)
}

// -------------------------------------------------------------------

// MoveEvent

// uint32 player_id = 1;
inline void MoveEvent::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = 0u;
}
inline ::uint32_t MoveEvent::player_id() const {
  // @@protoc_insertion_point(field_get:game.MoveEvent.player_id)
  return _internal_player_id();
}
inline void MoveEvent::set_player_id(::uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:game.MoveEvent.player_id)
}
inline ::uint32_t MoveEvent::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_;
}
inline void MoveEvent::_internal_set_player_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_ = value;
}

// .game.Vector3 position = 2;
inline bool MoveEvent::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void MoveEvent::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::game::Vector3& MoveEvent::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& MoveEvent::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.MoveEvent.position)
  return _internal_position();
}
inline void MoveEvent::unsafe_arena_set_allocated_position(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.MoveEvent.position)
}
inline ::game::Vector3* MoveEvent::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* MoveEvent::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.MoveEvent.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::game::Vector3* MoveEvent::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::game::Vector3* MoveEvent::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:game.MoveEvent.position)
  return _msg;
}
inline void MoveEvent::set_allocated_position(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.MoveEvent.position)
}

// .game.Vector3 velocity = 3;
inline bool MoveEvent::has_velocity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.velocity_ != nullptr);
  return value;
}
inline void MoveEvent::clear_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::game::Vector3& MoveEvent::_internal_velocity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.velocity_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& MoveEvent::velocity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.MoveEvent.velocity)
  return _internal_velocity();
}
inline void MoveEvent::unsafe_arena_set_allocated_velocity(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.velocity_);
  }
  _impl_.velocity_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.MoveEvent.velocity)
}
inline ::game::Vector3* MoveEvent::release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::game::Vector3* released = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* MoveEvent::unsafe_arena_release_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.MoveEvent.velocity)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::game::Vector3* temp = _impl_.velocity_;
  _impl_.velocity_ = nullptr;
  return temp;
}
inline ::game::Vector3* MoveEvent::_internal_mutable_velocity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.velocity_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.velocity_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.velocity_;
}
inline ::game::Vector3* MoveEvent::mutable_velocity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_velocity();
  // @@protoc_insertion_point(field_mutable:game.MoveEvent.velocity)
  return _msg;
}
inline void MoveEvent::set_allocated_velocity(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.velocity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.velocity_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.MoveEvent.velocity)
}

// uint64 server_time_ms = 6;
inline void MoveEvent::clear_server_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_time_ms_ = ::uint64_t{0u};
}
inline ::uint64_t MoveEvent::server_time_ms() const {
  // @@protoc_insertion_point(field_get:game.MoveEvent.server_time_ms)
  return _internal_server_time_ms();
}
inline void MoveEvent::set_server_time_ms(::uint64_t value) {
  _internal_set_server_time_ms(value);
  // @@protoc_insertion_point(field_set:game.MoveEvent.server_time_ms)
}
inline ::uint64_t MoveEvent::_internal_server_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_time_ms_;
}
inline void MoveEvent::_internal_set_server_time_ms(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.server_time_ms_ = value;
}

// -------------------------------------------------------------------

// FireInput

// uint64 tick = 1;
inline void FireInput::clear_tick() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.tick_ = ::uint64_t{0u};
}
inline ::uint64_t FireInput::tick() const {
  // @@protoc_insertion_point(field_get:game.FireInput.tick)
  return _internal_tick();
}
inline void FireInput::set_tick(::uint64_t value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:game.FireInput.tick)
}
inline ::uint64_t FireInput::_internal_tick() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.tick_;
}
inline void FireInput::_internal_set_tick(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.tick_ = value;
}

// uint32 weapon_id = 2;
inline void FireInput::clear_weapon_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weapon_id_ = 0u;
}
inline ::uint32_t FireInput::weapon_id() const {
  // @@protoc_insertion_point(field_get:game.FireInput.weapon_id)
  return _internal_weapon_id();
}
inline void FireInput::set_weapon_id(::uint32_t value) {
  _internal_set_weapon_id(value);
  // @@protoc_insertion_point(field_set:game.FireInput.weapon_id)
}
inline ::uint32_t FireInput::_internal_weapon_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weapon_id_;
}
inline void FireInput::_internal_set_weapon_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weapon_id_ = value;
}

// .game.Vector3 origin = 3;
inline bool FireInput::has_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.origin_ != nullptr);
  return value;
}
inline void FireInput::clear_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::game::Vector3& FireInput::_internal_origin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& FireInput::origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.FireInput.origin)
  return _internal_origin();
}
inline void FireInput::unsafe_arena_set_allocated_origin(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.FireInput.origin)
}
inline ::game::Vector3* FireInput::release_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* released = _impl_.origin_;
  _impl_.origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* FireInput::unsafe_arena_release_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.FireInput.origin)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::game::Vector3* FireInput::_internal_mutable_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.origin_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.origin_;
}
inline ::game::Vector3* FireInput::mutable_origin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:game.FireInput.origin)
  return _msg;
}
inline void FireInput::set_allocated_origin(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.origin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.origin_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.FireInput.origin)
}

// .game.Vector3 direction = 4;
inline bool FireInput::has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.direction_ != nullptr);
  return value;
}
inline void FireInput::clear_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::game::Vector3& FireInput::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& FireInput::direction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.FireInput.direction)
  return _internal_direction();
}
inline void FireInput::unsafe_arena_set_allocated_direction(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.FireInput.direction)
}
inline ::game::Vector3* FireInput::release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::game::Vector3* released = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* FireInput::unsafe_arena_release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.FireInput.direction)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::game::Vector3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::game::Vector3* FireInput::_internal_mutable_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.direction_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.direction_;
}
inline ::game::Vector3* FireInput::mutable_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:game.FireInput.direction)
  return _msg;
}
inline void FireInput::set_allocated_direction(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.direction_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.FireInput.direction)
}

// uint32 seed = 5;
inline void FireInput::clear_seed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.seed_ = 0u;
}
inline ::uint32_t FireInput::seed() const {
  // @@protoc_insertion_point(field_get:game.FireInput.seed)
  return _internal_seed();
}
inline void FireInput::set_seed(::uint32_t value) {
  _internal_set_seed(value);
  // @@protoc_insertion_point(field_set:game.FireInput.seed)
}
inline ::uint32_t FireInput::_internal_seed() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.seed_;
}
inline void FireInput::_internal_set_seed(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.seed_ = value;
}

// -------------------------------------------------------------------

// FireEvent

// uint32 player_id = 1;
inline void FireEvent::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = 0u;
}
inline ::uint32_t FireEvent::player_id() const {
  // @@protoc_insertion_point(field_get:game.FireEvent.player_id)
  return _internal_player_id();
}
inline void FireEvent::set_player_id(::uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:game.FireEvent.player_id)
}
inline ::uint32_t FireEvent::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_;
}
inline void FireEvent::_internal_set_player_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_ = value;
}

// uint32 bullet_id = 2;
inline void FireEvent::clear_bullet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bullet_id_ = 0u;
}
inline ::uint32_t FireEvent::bullet_id() const {
  // @@protoc_insertion_point(field_get:game.FireEvent.bullet_id)
  return _internal_bullet_id();
}
inline void FireEvent::set_bullet_id(::uint32_t value) {
  _internal_set_bullet_id(value);
  // @@protoc_insertion_point(field_set:game.FireEvent.bullet_id)
}
inline ::uint32_t FireEvent::_internal_bullet_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bullet_id_;
}
inline void FireEvent::_internal_set_bullet_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bullet_id_ = value;
}

// .game.Vector3 origin = 3;
inline bool FireEvent::has_origin() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.origin_ != nullptr);
  return value;
}
inline void FireEvent::clear_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::game::Vector3& FireEvent::_internal_origin() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& FireEvent::origin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.FireEvent.origin)
  return _internal_origin();
}
inline void FireEvent::unsafe_arena_set_allocated_origin(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.origin_);
  }
  _impl_.origin_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.FireEvent.origin)
}
inline ::game::Vector3* FireEvent::release_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* released = _impl_.origin_;
  _impl_.origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* FireEvent::unsafe_arena_release_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.FireEvent.origin)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* temp = _impl_.origin_;
  _impl_.origin_ = nullptr;
  return temp;
}
inline ::game::Vector3* FireEvent::_internal_mutable_origin() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.origin_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.origin_;
}
inline ::game::Vector3* FireEvent::mutable_origin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:game.FireEvent.origin)
  return _msg;
}
inline void FireEvent::set_allocated_origin(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.origin_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.origin_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.FireEvent.origin)
}

// .game.Vector3 direction = 4;
inline bool FireEvent::has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.direction_ != nullptr);
  return value;
}
inline void FireEvent::clear_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::game::Vector3& FireEvent::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& FireEvent::direction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.FireEvent.direction)
  return _internal_direction();
}
inline void FireEvent::unsafe_arena_set_allocated_direction(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.FireEvent.direction)
}
inline ::game::Vector3* FireEvent::release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::game::Vector3* released = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* FireEvent::unsafe_arena_release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.FireEvent.direction)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::game::Vector3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::game::Vector3* FireEvent::_internal_mutable_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.direction_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.direction_;
}
inline ::game::Vector3* FireEvent::mutable_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:game.FireEvent.direction)
  return _msg;
}
inline void FireEvent::set_allocated_direction(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.direction_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.FireEvent.direction)
}

// uint64 server_time_ms = 5;
inline void FireEvent::clear_server_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_time_ms_ = ::uint64_t{0u};
}
inline ::uint64_t FireEvent::server_time_ms() const {
  // @@protoc_insertion_point(field_get:game.FireEvent.server_time_ms)
  return _internal_server_time_ms();
}
inline void FireEvent::set_server_time_ms(::uint64_t value) {
  _internal_set_server_time_ms(value);
  // @@protoc_insertion_point(field_set:game.FireEvent.server_time_ms)
}
inline ::uint64_t FireEvent::_internal_server_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_time_ms_;
}
inline void FireEvent::_internal_set_server_time_ms(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.server_time_ms_ = value;
}

// -------------------------------------------------------------------

// HitEvent

// uint32 attacker_id = 1;
inline void HitEvent::clear_attacker_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.attacker_id_ = 0u;
}
inline ::uint32_t HitEvent::attacker_id() const {
  // @@protoc_insertion_point(field_get:game.HitEvent.attacker_id)
  return _internal_attacker_id();
}
inline void HitEvent::set_attacker_id(::uint32_t value) {
  _internal_set_attacker_id(value);
  // @@protoc_insertion_point(field_set:game.HitEvent.attacker_id)
}
inline ::uint32_t HitEvent::_internal_attacker_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.attacker_id_;
}
inline void HitEvent::_internal_set_attacker_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.attacker_id_ = value;
}

// uint32 target_id = 2;
inline void HitEvent::clear_target_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_id_ = 0u;
}
inline ::uint32_t HitEvent::target_id() const {
  // @@protoc_insertion_point(field_get:game.HitEvent.target_id)
  return _internal_target_id();
}
inline void HitEvent::set_target_id(::uint32_t value) {
  _internal_set_target_id(value);
  // @@protoc_insertion_point(field_set:game.HitEvent.target_id)
}
inline ::uint32_t HitEvent::_internal_target_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_id_;
}
inline void HitEvent::_internal_set_target_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_id_ = value;
}

// uint32 bullet_id = 3;
inline void HitEvent::clear_bullet_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.bullet_id_ = 0u;
}
inline ::uint32_t HitEvent::bullet_id() const {
  // @@protoc_insertion_point(field_get:game.HitEvent.bullet_id)
  return _internal_bullet_id();
}
inline void HitEvent::set_bullet_id(::uint32_t value) {
  _internal_set_bullet_id(value);
  // @@protoc_insertion_point(field_set:game.HitEvent.bullet_id)
}
inline ::uint32_t HitEvent::_internal_bullet_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.bullet_id_;
}
inline void HitEvent::_internal_set_bullet_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.bullet_id_ = value;
}

// uint32 damage = 4;
inline void HitEvent::clear_damage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.damage_ = 0u;
}
inline ::uint32_t HitEvent::damage() const {
  // @@protoc_insertion_point(field_get:game.HitEvent.damage)
  return _internal_damage();
}
inline void HitEvent::set_damage(::uint32_t value) {
  _internal_set_damage(value);
  // @@protoc_insertion_point(field_set:game.HitEvent.damage)
}
inline ::uint32_t HitEvent::_internal_damage() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.damage_;
}
inline void HitEvent::_internal_set_damage(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.damage_ = value;
}

// uint32 target_hp = 5;
inline void HitEvent::clear_target_hp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_hp_ = 0u;
}
inline ::uint32_t HitEvent::target_hp() const {
  // @@protoc_insertion_point(field_get:game.HitEvent.target_hp)
  return _internal_target_hp();
}
inline void HitEvent::set_target_hp(::uint32_t value) {
  _internal_set_target_hp(value);
  // @@protoc_insertion_point(field_set:game.HitEvent.target_hp)
}
inline ::uint32_t HitEvent::_internal_target_hp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_hp_;
}
inline void HitEvent::_internal_set_target_hp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.target_hp_ = value;
}

// uint64 server_time_ms = 6;
inline void HitEvent::clear_server_time_ms() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.server_time_ms_ = ::uint64_t{0u};
}
inline ::uint64_t HitEvent::server_time_ms() const {
  // @@protoc_insertion_point(field_get:game.HitEvent.server_time_ms)
  return _internal_server_time_ms();
}
inline void HitEvent::set_server_time_ms(::uint64_t value) {
  _internal_set_server_time_ms(value);
  // @@protoc_insertion_point(field_set:game.HitEvent.server_time_ms)
}
inline ::uint64_t HitEvent::_internal_server_time_ms() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.server_time_ms_;
}
inline void HitEvent::_internal_set_server_time_ms(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.server_time_ms_ = value;
}

// -------------------------------------------------------------------

// PlayerInfo

// uint32 player_id = 1;
inline void PlayerInfo::clear_player_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.player_id_ = 0u;
}
inline ::uint32_t PlayerInfo::player_id() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.player_id)
  return _internal_player_id();
}
inline void PlayerInfo::set_player_id(::uint32_t value) {
  _internal_set_player_id(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.player_id)
}
inline ::uint32_t PlayerInfo::_internal_player_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.player_id_;
}
inline void PlayerInfo::_internal_set_player_id(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.player_id_ = value;
}

// string nickname = 2;
inline void PlayerInfo::clear_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.ClearToEmpty();
}
inline const std::string& PlayerInfo::nickname() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.nickname)
  return _internal_nickname();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PlayerInfo::set_nickname(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:game.PlayerInfo.nickname)
}
inline std::string* PlayerInfo::mutable_nickname() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:game.PlayerInfo.nickname)
  return _s;
}
inline const std::string& PlayerInfo::_internal_nickname() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.nickname_.Get();
}
inline void PlayerInfo::_internal_set_nickname(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nickname_.Set(value, GetArena());
}
inline std::string* PlayerInfo::_internal_mutable_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.nickname_.Mutable( GetArena());
}
inline std::string* PlayerInfo::release_nickname() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.PlayerInfo.nickname)
  return _impl_.nickname_.Release();
}
inline void PlayerInfo::set_allocated_nickname(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nickname_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.nickname_.IsDefault()) {
          _impl_.nickname_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:game.PlayerInfo.nickname)
}

// .game.Vector3 position = 3;
inline bool PlayerInfo::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void PlayerInfo::clear_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::game::Vector3& PlayerInfo::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Vector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Vector3&>(::game::_Vector3_default_instance_);
}
inline const ::game::Vector3& PlayerInfo::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.position)
  return _internal_position();
}
inline void PlayerInfo::unsafe_arena_set_allocated_position(::game::Vector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::game::Vector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.PlayerInfo.position)
}
inline ::game::Vector3* PlayerInfo::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Vector3* PlayerInfo::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.PlayerInfo.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Vector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::game::Vector3* PlayerInfo::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Vector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::game::Vector3*>(p);
  }
  return _impl_.position_;
}
inline ::game::Vector3* PlayerInfo::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Vector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:game.PlayerInfo.position)
  return _msg;
}
inline void PlayerInfo::set_allocated_position(::game::Vector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Vector3*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Vector3*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::game::Vector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.PlayerInfo.position)
}

// uint32 hp = 4;
inline void PlayerInfo::clear_hp() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.hp_ = 0u;
}
inline ::uint32_t PlayerInfo::hp() const {
  // @@protoc_insertion_point(field_get:game.PlayerInfo.hp)
  return _internal_hp();
}
inline void PlayerInfo::set_hp(::uint32_t value) {
  _internal_set_hp(value);
  // @@protoc_insertion_point(field_set:game.PlayerInfo.hp)
}
inline ::uint32_t PlayerInfo::_internal_hp() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.hp_;
}
inline void PlayerInfo::_internal_set_hp(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hp_ = value;
}

// -------------------------------------------------------------------

// AllPlayerList

// repeated .game.PlayerInfo players = 1;
inline int AllPlayerList::_internal_players_size() const {
  return _internal_players().size();
}
inline int AllPlayerList::players_size() const {
  return _internal_players_size();
}
inline void AllPlayerList::clear_players() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.players_.Clear();
}
inline ::game::PlayerInfo* AllPlayerList::mutable_players(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:game.AllPlayerList.players)
  return _internal_mutable_players()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>* AllPlayerList::mutable_players()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:game.AllPlayerList.players)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players();
}
inline const ::game::PlayerInfo& AllPlayerList::players(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.AllPlayerList.players)
  return _internal_players().Get(index);
}
inline ::game::PlayerInfo* AllPlayerList::add_players() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::game::PlayerInfo* _add = _internal_mutable_players()->Add();
  // @@protoc_insertion_point(field_add:game.AllPlayerList.players)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>& AllPlayerList::players() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:game.AllPlayerList.players)
  return _internal_players();
}
inline const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>&
AllPlayerList::_internal_players() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_;
}
inline ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>*
AllPlayerList::_internal_mutable_players() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_;
}

// -------------------------------------------------------------------

// PlayerStateUpdate

// repeated .game.PlayerInfo players_updated = 1;
inline int PlayerStateUpdate::_internal_players_updated_size() const {
  return _internal_players_updated().size();
}
inline int PlayerStateUpdate::players_updated_size() const {
  return _internal_players_updated_size();
}
inline void PlayerStateUpdate::clear_players_updated() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.players_updated_.Clear();
}
inline ::game::PlayerInfo* PlayerStateUpdate::mutable_players_updated(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:game.PlayerStateUpdate.players_updated)
  return _internal_mutable_players_updated()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>* PlayerStateUpdate::mutable_players_updated()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:game.PlayerStateUpdate.players_updated)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players_updated();
}
inline const ::game::PlayerInfo& PlayerStateUpdate::players_updated(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.PlayerStateUpdate.players_updated)
  return _internal_players_updated().Get(index);
}
inline ::game::PlayerInfo* PlayerStateUpdate::add_players_updated() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::game::PlayerInfo* _add = _internal_mutable_players_updated()->Add();
  // @@protoc_insertion_point(field_add:game.PlayerStateUpdate.players_updated)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>& PlayerStateUpdate::players_updated() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:game.PlayerStateUpdate.players_updated)
  return _internal_players_updated();
}
inline const ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>&
PlayerStateUpdate::_internal_players_updated() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_updated_;
}
inline ::google::protobuf::RepeatedPtrField<::game::PlayerInfo>*
PlayerStateUpdate::_internal_mutable_players_updated() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_updated_;
}

// repeated uint32 players_removed = 2;
inline int PlayerStateUpdate::_internal_players_removed_size() const {
  return _internal_players_removed().size();
}
inline int PlayerStateUpdate::players_removed_size() const {
  return _internal_players_removed_size();
}
inline void PlayerStateUpdate::clear_players_removed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.players_removed_.Clear();
}
inline ::uint32_t PlayerStateUpdate::players_removed(int index) const {
  // @@protoc_insertion_point(field_get:game.PlayerStateUpdate.players_removed)
  return _internal_players_removed().Get(index);
}
inline void PlayerStateUpdate::set_players_removed(int index, ::uint32_t value) {
  _internal_mutable_players_removed()->Set(index, value);
  // @@protoc_insertion_point(field_set:game.PlayerStateUpdate.players_removed)
}
inline void PlayerStateUpdate::add_players_removed(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_players_removed()->Add(value);
  // @@protoc_insertion_point(field_add:game.PlayerStateUpdate.players_removed)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PlayerStateUpdate::players_removed() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:game.PlayerStateUpdate.players_removed)
  return _internal_players_removed();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PlayerStateUpdate::mutable_players_removed()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:game.PlayerStateUpdate.players_removed)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_players_removed();
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& PlayerStateUpdate::_internal_players_removed()
    const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.players_removed_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* PlayerStateUpdate::_internal_mutable_players_removed() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.players_removed_;
}

// -------------------------------------------------------------------

// GameMessage

// .game.Header header = 1;
inline bool GameMessage::has_header() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.header_ != nullptr);
  return value;
}
inline void GameMessage::clear_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.header_ != nullptr) _impl_.header_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::game::Header& GameMessage::_internal_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::game::Header* p = _impl_.header_;
  return p != nullptr ? *p : reinterpret_cast<const ::game::Header&>(::game::_Header_default_instance_);
}
inline const ::game::Header& GameMessage::header() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.header)
  return _internal_header();
}
inline void GameMessage::unsafe_arena_set_allocated_header(::game::Header* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.header_);
  }
  _impl_.header_ = reinterpret_cast<::game::Header*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.header)
}
inline ::game::Header* GameMessage::release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Header* released = _impl_.header_;
  _impl_.header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::game::Header* GameMessage::unsafe_arena_release_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:game.GameMessage.header)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::game::Header* temp = _impl_.header_;
  _impl_.header_ = nullptr;
  return temp;
}
inline ::game::Header* GameMessage::_internal_mutable_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.header_ == nullptr) {
    auto* p = CreateMaybeMessage<::game::Header>(GetArena());
    _impl_.header_ = reinterpret_cast<::game::Header*>(p);
  }
  return _impl_.header_;
}
inline ::game::Header* GameMessage::mutable_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.header)
  return _msg;
}
inline void GameMessage::set_allocated_header(::game::Header* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::game::Header*>(_impl_.header_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::game::Header*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.header_ = reinterpret_cast<::game::Header*>(value);
  // @@protoc_insertion_point(field_set_allocated:game.GameMessage.header)
}

// .game.LoginRequest login_request = 10;
inline bool GameMessage::has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline bool GameMessage::_internal_has_login_request() const {
  return payload_case() == kLoginRequest;
}
inline void GameMessage::set_has_login_request() {
  _impl_._oneof_case_[0] = kLoginRequest;
}
inline void GameMessage::clear_login_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kLoginRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.login_request_;
    }
    clear_has_payload();
  }
}
inline ::game::LoginRequest* GameMessage::release_login_request() {
  // @@protoc_insertion_point(field_release:game.GameMessage.login_request)
  if (payload_case() == kLoginRequest) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginRequest& GameMessage::_internal_login_request() const {
  return payload_case() == kLoginRequest ? *_impl_.payload_.login_request_ : reinterpret_cast<::game::LoginRequest&>(::game::_LoginRequest_default_instance_);
}
inline const ::game::LoginRequest& GameMessage::login_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.login_request)
  return _internal_login_request();
}
inline ::game::LoginRequest* GameMessage::unsafe_arena_release_login_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.login_request)
  if (payload_case() == kLoginRequest) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_request_;
    _impl_.payload_.login_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_login_request(::game::LoginRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_login_request();
    _impl_.payload_.login_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.login_request)
}
inline ::game::LoginRequest* GameMessage::_internal_mutable_login_request() {
  if (payload_case() != kLoginRequest) {
    clear_payload();
    set_has_login_request();
    _impl_.payload_.login_request_ = CreateMaybeMessage<::game::LoginRequest>(GetArena());
  }
  return _impl_.payload_.login_request_;
}
inline ::game::LoginRequest* GameMessage::mutable_login_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::LoginRequest* _msg = _internal_mutable_login_request();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.login_request)
  return _msg;
}

// .game.LoginResponse login_response = 11;
inline bool GameMessage::has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline bool GameMessage::_internal_has_login_response() const {
  return payload_case() == kLoginResponse;
}
inline void GameMessage::set_has_login_response() {
  _impl_._oneof_case_[0] = kLoginResponse;
}
inline void GameMessage::clear_login_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kLoginResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.login_response_;
    }
    clear_has_payload();
  }
}
inline ::game::LoginResponse* GameMessage::release_login_response() {
  // @@protoc_insertion_point(field_release:game.GameMessage.login_response)
  if (payload_case() == kLoginResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::LoginResponse& GameMessage::_internal_login_response() const {
  return payload_case() == kLoginResponse ? *_impl_.payload_.login_response_ : reinterpret_cast<::game::LoginResponse&>(::game::_LoginResponse_default_instance_);
}
inline const ::game::LoginResponse& GameMessage::login_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.login_response)
  return _internal_login_response();
}
inline ::game::LoginResponse* GameMessage::unsafe_arena_release_login_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.login_response)
  if (payload_case() == kLoginResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.login_response_;
    _impl_.payload_.login_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_login_response(::game::LoginResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_login_response();
    _impl_.payload_.login_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.login_response)
}
inline ::game::LoginResponse* GameMessage::_internal_mutable_login_response() {
  if (payload_case() != kLoginResponse) {
    clear_payload();
    set_has_login_response();
    _impl_.payload_.login_response_ = CreateMaybeMessage<::game::LoginResponse>(GetArena());
  }
  return _impl_.payload_.login_response_;
}
inline ::game::LoginResponse* GameMessage::mutable_login_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::LoginResponse* _msg = _internal_mutable_login_response();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.login_response)
  return _msg;
}

// .game.JoinRoomRequest join_room_request = 12;
inline bool GameMessage::has_join_room_request() const {
  return payload_case() == kJoinRoomRequest;
}
inline bool GameMessage::_internal_has_join_room_request() const {
  return payload_case() == kJoinRoomRequest;
}
inline void GameMessage::set_has_join_room_request() {
  _impl_._oneof_case_[0] = kJoinRoomRequest;
}
inline void GameMessage::clear_join_room_request() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kJoinRoomRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.join_room_request_;
    }
    clear_has_payload();
  }
}
inline ::game::JoinRoomRequest* GameMessage::release_join_room_request() {
  // @@protoc_insertion_point(field_release:game.GameMessage.join_room_request)
  if (payload_case() == kJoinRoomRequest) {
    clear_has_payload();
    auto* temp = _impl_.payload_.join_room_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.join_room_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::JoinRoomRequest& GameMessage::_internal_join_room_request() const {
  return payload_case() == kJoinRoomRequest ? *_impl_.payload_.join_room_request_ : reinterpret_cast<::game::JoinRoomRequest&>(::game::_JoinRoomRequest_default_instance_);
}
inline const ::game::JoinRoomRequest& GameMessage::join_room_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.join_room_request)
  return _internal_join_room_request();
}
inline ::game::JoinRoomRequest* GameMessage::unsafe_arena_release_join_room_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.join_room_request)
  if (payload_case() == kJoinRoomRequest) {
    clear_has_payload();
    auto* temp = _impl_.payload_.join_room_request_;
    _impl_.payload_.join_room_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_join_room_request(::game::JoinRoomRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_join_room_request();
    _impl_.payload_.join_room_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.join_room_request)
}
inline ::game::JoinRoomRequest* GameMessage::_internal_mutable_join_room_request() {
  if (payload_case() != kJoinRoomRequest) {
    clear_payload();
    set_has_join_room_request();
    _impl_.payload_.join_room_request_ = CreateMaybeMessage<::game::JoinRoomRequest>(GetArena());
  }
  return _impl_.payload_.join_room_request_;
}
inline ::game::JoinRoomRequest* GameMessage::mutable_join_room_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::JoinRoomRequest* _msg = _internal_mutable_join_room_request();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.join_room_request)
  return _msg;
}

// .game.JoinRoomResponse join_room_response = 13;
inline bool GameMessage::has_join_room_response() const {
  return payload_case() == kJoinRoomResponse;
}
inline bool GameMessage::_internal_has_join_room_response() const {
  return payload_case() == kJoinRoomResponse;
}
inline void GameMessage::set_has_join_room_response() {
  _impl_._oneof_case_[0] = kJoinRoomResponse;
}
inline void GameMessage::clear_join_room_response() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kJoinRoomResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.join_room_response_;
    }
    clear_has_payload();
  }
}
inline ::game::JoinRoomResponse* GameMessage::release_join_room_response() {
  // @@protoc_insertion_point(field_release:game.GameMessage.join_room_response)
  if (payload_case() == kJoinRoomResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.join_room_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.join_room_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::JoinRoomResponse& GameMessage::_internal_join_room_response() const {
  return payload_case() == kJoinRoomResponse ? *_impl_.payload_.join_room_response_ : reinterpret_cast<::game::JoinRoomResponse&>(::game::_JoinRoomResponse_default_instance_);
}
inline const ::game::JoinRoomResponse& GameMessage::join_room_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.join_room_response)
  return _internal_join_room_response();
}
inline ::game::JoinRoomResponse* GameMessage::unsafe_arena_release_join_room_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.join_room_response)
  if (payload_case() == kJoinRoomResponse) {
    clear_has_payload();
    auto* temp = _impl_.payload_.join_room_response_;
    _impl_.payload_.join_room_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_join_room_response(::game::JoinRoomResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_join_room_response();
    _impl_.payload_.join_room_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.join_room_response)
}
inline ::game::JoinRoomResponse* GameMessage::_internal_mutable_join_room_response() {
  if (payload_case() != kJoinRoomResponse) {
    clear_payload();
    set_has_join_room_response();
    _impl_.payload_.join_room_response_ = CreateMaybeMessage<::game::JoinRoomResponse>(GetArena());
  }
  return _impl_.payload_.join_room_response_;
}
inline ::game::JoinRoomResponse* GameMessage::mutable_join_room_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::JoinRoomResponse* _msg = _internal_mutable_join_room_response();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.join_room_response)
  return _msg;
}

// .game.ChatSend chat_send = 20;
inline bool GameMessage::has_chat_send() const {
  return payload_case() == kChatSend;
}
inline bool GameMessage::_internal_has_chat_send() const {
  return payload_case() == kChatSend;
}
inline void GameMessage::set_has_chat_send() {
  _impl_._oneof_case_[0] = kChatSend;
}
inline void GameMessage::clear_chat_send() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kChatSend) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.chat_send_;
    }
    clear_has_payload();
  }
}
inline ::game::ChatSend* GameMessage::release_chat_send() {
  // @@protoc_insertion_point(field_release:game.GameMessage.chat_send)
  if (payload_case() == kChatSend) {
    clear_has_payload();
    auto* temp = _impl_.payload_.chat_send_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.chat_send_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ChatSend& GameMessage::_internal_chat_send() const {
  return payload_case() == kChatSend ? *_impl_.payload_.chat_send_ : reinterpret_cast<::game::ChatSend&>(::game::_ChatSend_default_instance_);
}
inline const ::game::ChatSend& GameMessage::chat_send() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.chat_send)
  return _internal_chat_send();
}
inline ::game::ChatSend* GameMessage::unsafe_arena_release_chat_send() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.chat_send)
  if (payload_case() == kChatSend) {
    clear_has_payload();
    auto* temp = _impl_.payload_.chat_send_;
    _impl_.payload_.chat_send_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_chat_send(::game::ChatSend* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_chat_send();
    _impl_.payload_.chat_send_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.chat_send)
}
inline ::game::ChatSend* GameMessage::_internal_mutable_chat_send() {
  if (payload_case() != kChatSend) {
    clear_payload();
    set_has_chat_send();
    _impl_.payload_.chat_send_ = CreateMaybeMessage<::game::ChatSend>(GetArena());
  }
  return _impl_.payload_.chat_send_;
}
inline ::game::ChatSend* GameMessage::mutable_chat_send() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::ChatSend* _msg = _internal_mutable_chat_send();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.chat_send)
  return _msg;
}

// .game.ChatEvent chat_event = 21;
inline bool GameMessage::has_chat_event() const {
  return payload_case() == kChatEvent;
}
inline bool GameMessage::_internal_has_chat_event() const {
  return payload_case() == kChatEvent;
}
inline void GameMessage::set_has_chat_event() {
  _impl_._oneof_case_[0] = kChatEvent;
}
inline void GameMessage::clear_chat_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kChatEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.chat_event_;
    }
    clear_has_payload();
  }
}
inline ::game::ChatEvent* GameMessage::release_chat_event() {
  // @@protoc_insertion_point(field_release:game.GameMessage.chat_event)
  if (payload_case() == kChatEvent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.chat_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.chat_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::ChatEvent& GameMessage::_internal_chat_event() const {
  return payload_case() == kChatEvent ? *_impl_.payload_.chat_event_ : reinterpret_cast<::game::ChatEvent&>(::game::_ChatEvent_default_instance_);
}
inline const ::game::ChatEvent& GameMessage::chat_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.chat_event)
  return _internal_chat_event();
}
inline ::game::ChatEvent* GameMessage::unsafe_arena_release_chat_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.chat_event)
  if (payload_case() == kChatEvent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.chat_event_;
    _impl_.payload_.chat_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_chat_event(::game::ChatEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_chat_event();
    _impl_.payload_.chat_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.chat_event)
}
inline ::game::ChatEvent* GameMessage::_internal_mutable_chat_event() {
  if (payload_case() != kChatEvent) {
    clear_payload();
    set_has_chat_event();
    _impl_.payload_.chat_event_ = CreateMaybeMessage<::game::ChatEvent>(GetArena());
  }
  return _impl_.payload_.chat_event_;
}
inline ::game::ChatEvent* GameMessage::mutable_chat_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::ChatEvent* _msg = _internal_mutable_chat_event();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.chat_event)
  return _msg;
}

// .game.MoveInput move_input = 30;
inline bool GameMessage::has_move_input() const {
  return payload_case() == kMoveInput;
}
inline bool GameMessage::_internal_has_move_input() const {
  return payload_case() == kMoveInput;
}
inline void GameMessage::set_has_move_input() {
  _impl_._oneof_case_[0] = kMoveInput;
}
inline void GameMessage::clear_move_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kMoveInput) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.move_input_;
    }
    clear_has_payload();
  }
}
inline ::game::MoveInput* GameMessage::release_move_input() {
  // @@protoc_insertion_point(field_release:game.GameMessage.move_input)
  if (payload_case() == kMoveInput) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_input_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.move_input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::MoveInput& GameMessage::_internal_move_input() const {
  return payload_case() == kMoveInput ? *_impl_.payload_.move_input_ : reinterpret_cast<::game::MoveInput&>(::game::_MoveInput_default_instance_);
}
inline const ::game::MoveInput& GameMessage::move_input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.move_input)
  return _internal_move_input();
}
inline ::game::MoveInput* GameMessage::unsafe_arena_release_move_input() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.move_input)
  if (payload_case() == kMoveInput) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_input_;
    _impl_.payload_.move_input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_move_input(::game::MoveInput* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_move_input();
    _impl_.payload_.move_input_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.move_input)
}
inline ::game::MoveInput* GameMessage::_internal_mutable_move_input() {
  if (payload_case() != kMoveInput) {
    clear_payload();
    set_has_move_input();
    _impl_.payload_.move_input_ = CreateMaybeMessage<::game::MoveInput>(GetArena());
  }
  return _impl_.payload_.move_input_;
}
inline ::game::MoveInput* GameMessage::mutable_move_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::MoveInput* _msg = _internal_mutable_move_input();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.move_input)
  return _msg;
}

// .game.MoveEvent move_event = 31;
inline bool GameMessage::has_move_event() const {
  return payload_case() == kMoveEvent;
}
inline bool GameMessage::_internal_has_move_event() const {
  return payload_case() == kMoveEvent;
}
inline void GameMessage::set_has_move_event() {
  _impl_._oneof_case_[0] = kMoveEvent;
}
inline void GameMessage::clear_move_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kMoveEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.move_event_;
    }
    clear_has_payload();
  }
}
inline ::game::MoveEvent* GameMessage::release_move_event() {
  // @@protoc_insertion_point(field_release:game.GameMessage.move_event)
  if (payload_case() == kMoveEvent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.move_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::MoveEvent& GameMessage::_internal_move_event() const {
  return payload_case() == kMoveEvent ? *_impl_.payload_.move_event_ : reinterpret_cast<::game::MoveEvent&>(::game::_MoveEvent_default_instance_);
}
inline const ::game::MoveEvent& GameMessage::move_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.move_event)
  return _internal_move_event();
}
inline ::game::MoveEvent* GameMessage::unsafe_arena_release_move_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.move_event)
  if (payload_case() == kMoveEvent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.move_event_;
    _impl_.payload_.move_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_move_event(::game::MoveEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_move_event();
    _impl_.payload_.move_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.move_event)
}
inline ::game::MoveEvent* GameMessage::_internal_mutable_move_event() {
  if (payload_case() != kMoveEvent) {
    clear_payload();
    set_has_move_event();
    _impl_.payload_.move_event_ = CreateMaybeMessage<::game::MoveEvent>(GetArena());
  }
  return _impl_.payload_.move_event_;
}
inline ::game::MoveEvent* GameMessage::mutable_move_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::MoveEvent* _msg = _internal_mutable_move_event();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.move_event)
  return _msg;
}

// .game.FireInput fire_input = 32;
inline bool GameMessage::has_fire_input() const {
  return payload_case() == kFireInput;
}
inline bool GameMessage::_internal_has_fire_input() const {
  return payload_case() == kFireInput;
}
inline void GameMessage::set_has_fire_input() {
  _impl_._oneof_case_[0] = kFireInput;
}
inline void GameMessage::clear_fire_input() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kFireInput) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.fire_input_;
    }
    clear_has_payload();
  }
}
inline ::game::FireInput* GameMessage::release_fire_input() {
  // @@protoc_insertion_point(field_release:game.GameMessage.fire_input)
  if (payload_case() == kFireInput) {
    clear_has_payload();
    auto* temp = _impl_.payload_.fire_input_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.fire_input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::FireInput& GameMessage::_internal_fire_input() const {
  return payload_case() == kFireInput ? *_impl_.payload_.fire_input_ : reinterpret_cast<::game::FireInput&>(::game::_FireInput_default_instance_);
}
inline const ::game::FireInput& GameMessage::fire_input() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.fire_input)
  return _internal_fire_input();
}
inline ::game::FireInput* GameMessage::unsafe_arena_release_fire_input() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.fire_input)
  if (payload_case() == kFireInput) {
    clear_has_payload();
    auto* temp = _impl_.payload_.fire_input_;
    _impl_.payload_.fire_input_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_fire_input(::game::FireInput* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_fire_input();
    _impl_.payload_.fire_input_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.fire_input)
}
inline ::game::FireInput* GameMessage::_internal_mutable_fire_input() {
  if (payload_case() != kFireInput) {
    clear_payload();
    set_has_fire_input();
    _impl_.payload_.fire_input_ = CreateMaybeMessage<::game::FireInput>(GetArena());
  }
  return _impl_.payload_.fire_input_;
}
inline ::game::FireInput* GameMessage::mutable_fire_input() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::FireInput* _msg = _internal_mutable_fire_input();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.fire_input)
  return _msg;
}

// .game.FireEvent fire_event = 33;
inline bool GameMessage::has_fire_event() const {
  return payload_case() == kFireEvent;
}
inline bool GameMessage::_internal_has_fire_event() const {
  return payload_case() == kFireEvent;
}
inline void GameMessage::set_has_fire_event() {
  _impl_._oneof_case_[0] = kFireEvent;
}
inline void GameMessage::clear_fire_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kFireEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.fire_event_;
    }
    clear_has_payload();
  }
}
inline ::game::FireEvent* GameMessage::release_fire_event() {
  // @@protoc_insertion_point(field_release:game.GameMessage.fire_event)
  if (payload_case() == kFireEvent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.fire_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.fire_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::FireEvent& GameMessage::_internal_fire_event() const {
  return payload_case() == kFireEvent ? *_impl_.payload_.fire_event_ : reinterpret_cast<::game::FireEvent&>(::game::_FireEvent_default_instance_);
}
inline const ::game::FireEvent& GameMessage::fire_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.fire_event)
  return _internal_fire_event();
}
inline ::game::FireEvent* GameMessage::unsafe_arena_release_fire_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.fire_event)
  if (payload_case() == kFireEvent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.fire_event_;
    _impl_.payload_.fire_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_fire_event(::game::FireEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_fire_event();
    _impl_.payload_.fire_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.fire_event)
}
inline ::game::FireEvent* GameMessage::_internal_mutable_fire_event() {
  if (payload_case() != kFireEvent) {
    clear_payload();
    set_has_fire_event();
    _impl_.payload_.fire_event_ = CreateMaybeMessage<::game::FireEvent>(GetArena());
  }
  return _impl_.payload_.fire_event_;
}
inline ::game::FireEvent* GameMessage::mutable_fire_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::FireEvent* _msg = _internal_mutable_fire_event();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.fire_event)
  return _msg;
}

// .game.HitEvent hit_event = 34;
inline bool GameMessage::has_hit_event() const {
  return payload_case() == kHitEvent;
}
inline bool GameMessage::_internal_has_hit_event() const {
  return payload_case() == kHitEvent;
}
inline void GameMessage::set_has_hit_event() {
  _impl_._oneof_case_[0] = kHitEvent;
}
inline void GameMessage::clear_hit_event() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kHitEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.hit_event_;
    }
    clear_has_payload();
  }
}
inline ::game::HitEvent* GameMessage::release_hit_event() {
  // @@protoc_insertion_point(field_release:game.GameMessage.hit_event)
  if (payload_case() == kHitEvent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.hit_event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.hit_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::HitEvent& GameMessage::_internal_hit_event() const {
  return payload_case() == kHitEvent ? *_impl_.payload_.hit_event_ : reinterpret_cast<::game::HitEvent&>(::game::_HitEvent_default_instance_);
}
inline const ::game::HitEvent& GameMessage::hit_event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.hit_event)
  return _internal_hit_event();
}
inline ::game::HitEvent* GameMessage::unsafe_arena_release_hit_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.hit_event)
  if (payload_case() == kHitEvent) {
    clear_has_payload();
    auto* temp = _impl_.payload_.hit_event_;
    _impl_.payload_.hit_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_hit_event(::game::HitEvent* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_hit_event();
    _impl_.payload_.hit_event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.hit_event)
}
inline ::game::HitEvent* GameMessage::_internal_mutable_hit_event() {
  if (payload_case() != kHitEvent) {
    clear_payload();
    set_has_hit_event();
    _impl_.payload_.hit_event_ = CreateMaybeMessage<::game::HitEvent>(GetArena());
  }
  return _impl_.payload_.hit_event_;
}
inline ::game::HitEvent* GameMessage::mutable_hit_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::HitEvent* _msg = _internal_mutable_hit_event();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.hit_event)
  return _msg;
}

// .game.AllPlayerList all_player_list = 40;
inline bool GameMessage::has_all_player_list() const {
  return payload_case() == kAllPlayerList;
}
inline bool GameMessage::_internal_has_all_player_list() const {
  return payload_case() == kAllPlayerList;
}
inline void GameMessage::set_has_all_player_list() {
  _impl_._oneof_case_[0] = kAllPlayerList;
}
inline void GameMessage::clear_all_player_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kAllPlayerList) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.all_player_list_;
    }
    clear_has_payload();
  }
}
inline ::game::AllPlayerList* GameMessage::release_all_player_list() {
  // @@protoc_insertion_point(field_release:game.GameMessage.all_player_list)
  if (payload_case() == kAllPlayerList) {
    clear_has_payload();
    auto* temp = _impl_.payload_.all_player_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.all_player_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::AllPlayerList& GameMessage::_internal_all_player_list() const {
  return payload_case() == kAllPlayerList ? *_impl_.payload_.all_player_list_ : reinterpret_cast<::game::AllPlayerList&>(::game::_AllPlayerList_default_instance_);
}
inline const ::game::AllPlayerList& GameMessage::all_player_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.all_player_list)
  return _internal_all_player_list();
}
inline ::game::AllPlayerList* GameMessage::unsafe_arena_release_all_player_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.all_player_list)
  if (payload_case() == kAllPlayerList) {
    clear_has_payload();
    auto* temp = _impl_.payload_.all_player_list_;
    _impl_.payload_.all_player_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_all_player_list(::game::AllPlayerList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_all_player_list();
    _impl_.payload_.all_player_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.all_player_list)
}
inline ::game::AllPlayerList* GameMessage::_internal_mutable_all_player_list() {
  if (payload_case() != kAllPlayerList) {
    clear_payload();
    set_has_all_player_list();
    _impl_.payload_.all_player_list_ = CreateMaybeMessage<::game::AllPlayerList>(GetArena());
  }
  return _impl_.payload_.all_player_list_;
}
inline ::game::AllPlayerList* GameMessage::mutable_all_player_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::AllPlayerList* _msg = _internal_mutable_all_player_list();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.all_player_list)
  return _msg;
}

// .game.PlayerStateUpdate player_state_update = 41;
inline bool GameMessage::has_player_state_update() const {
  return payload_case() == kPlayerStateUpdate;
}
inline bool GameMessage::_internal_has_player_state_update() const {
  return payload_case() == kPlayerStateUpdate;
}
inline void GameMessage::set_has_player_state_update() {
  _impl_._oneof_case_[0] = kPlayerStateUpdate;
}
inline void GameMessage::clear_player_state_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (payload_case() == kPlayerStateUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.payload_.player_state_update_;
    }
    clear_has_payload();
  }
}
inline ::game::PlayerStateUpdate* GameMessage::release_player_state_update() {
  // @@protoc_insertion_point(field_release:game.GameMessage.player_state_update)
  if (payload_case() == kPlayerStateUpdate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.player_state_update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.player_state_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::game::PlayerStateUpdate& GameMessage::_internal_player_state_update() const {
  return payload_case() == kPlayerStateUpdate ? *_impl_.payload_.player_state_update_ : reinterpret_cast<::game::PlayerStateUpdate&>(::game::_PlayerStateUpdate_default_instance_);
}
inline const ::game::PlayerStateUpdate& GameMessage::player_state_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:game.GameMessage.player_state_update)
  return _internal_player_state_update();
}
inline ::game::PlayerStateUpdate* GameMessage::unsafe_arena_release_player_state_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:game.GameMessage.player_state_update)
  if (payload_case() == kPlayerStateUpdate) {
    clear_has_payload();
    auto* temp = _impl_.payload_.player_state_update_;
    _impl_.payload_.player_state_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void GameMessage::unsafe_arena_set_allocated_player_state_update(::game::PlayerStateUpdate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_payload();
  if (value) {
    set_has_player_state_update();
    _impl_.payload_.player_state_update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:game.GameMessage.player_state_update)
}
inline ::game::PlayerStateUpdate* GameMessage::_internal_mutable_player_state_update() {
  if (payload_case() != kPlayerStateUpdate) {
    clear_payload();
    set_has_player_state_update();
    _impl_.payload_.player_state_update_ = CreateMaybeMessage<::game::PlayerStateUpdate>(GetArena());
  }
  return _impl_.payload_.player_state_update_;
}
inline ::game::PlayerStateUpdate* GameMessage::mutable_player_state_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::game::PlayerStateUpdate* _msg = _internal_mutable_player_state_update();
  // @@protoc_insertion_point(field_mutable:game.GameMessage.player_state_update)
  return _msg;
}

inline bool GameMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void GameMessage::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline GameMessage::PayloadCase GameMessage::payload_case() const {
  return GameMessage::PayloadCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace game


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::game::StatusCode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::game::StatusCode>() {
  return ::game::StatusCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_game_5fmessage_2eproto_2epb_2eh
